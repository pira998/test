const w = {
  slate: {
    c50: "#f8fafc",
    c100: "#f1f5f9",
    c200: "#e2e8f0",
    c300: "#cbd5e1",
    c400: "#94a3b8",
    c500: "#64748b",
    c600: "#475569",
    c700: "#334155",
    c800: "#1e293b",
    c900: "#0f172a",
    c950: "#020617"
  },
  gray: {
    c50: "#f9fafb",
    c100: "#f3f4f6",
    c200: "#e5e7eb",
    c300: "#d1d5db",
    c400: "#9ca3af",
    c500: "#6b7280",
    c600: "#4b5563",
    c700: "#374151",
    c800: "#1f2937",
    c900: "#111827",
    c950: "#030712"
  },
  zinc: {
    c50: "#161A1D",
    c100: "#1D2125",
    c200: "#22272B",
    c300: "#282E33",
    c400: "#454F59",
    c500: "#596773",
    c600: "#738496",
    c700: "#8C9BAB",
    c800: "#9FADBC",
    c900: "#B6C2CF",
    c950: "#C7D1DB"
  },
  neutral: {
    c50: "#fafafa",
    c100: "#f5f5f5",
    c200: "#e5e5e5",
    c300: "#d4d4d4",
    c400: "#a3a3a3",
    c500: "#737373",
    c600: "#525252",
    c700: "#404040",
    c800: "#262626",
    c900: "#171717",
    c950: "#0a0a0a"
  },
  stone: {
    c50: "#fafaf9",
    c100: "#f5f5f4",
    c200: "#e7e5e4",
    c300: "#d6d3d1",
    c400: "#a8a29e",
    c500: "#78716c",
    c600: "#57534e",
    c700: "#44403c",
    c800: "#292524",
    c900: "#1c1917",
    c950: "#0c0a09"
  },
  red: {
    c50: "#fef2f2",
    c100: "#fee2e2",
    c200: "#fecaca",
    c300: "#fca5a5",
    c400: "#f87171",
    c500: "#ef4444",
    c600: "#dc2626",
    c700: "#b91c1c",
    c800: "#991b1b",
    c900: "#7f1d1d",
    c950: "#450a0a"
  },
  orange: {
    c50: "#fff7ed",
    c100: "#ffedd5",
    c200: "#fed7aa",
    c300: "#fdba74",
    c400: "#fb923c",
    c500: "#f97316",
    c600: "#ea580c",
    c700: "#c2410c",
    c800: "#9a3412",
    c900: "#7c2d12",
    c950: "#431407"
  },
  amber: {
    c50: "#fffbeb",
    c100: "#fef3c7",
    c200: "#fde68a",
    c300: "#fcd34d",
    c400: "#fbbf24",
    c500: "#f59e0b",
    c600: "#d97706",
    c700: "#b45309",
    c800: "#92400e",
    c900: "#78350f",
    c950: "#451a03"
  },
  yellow: {
    c50: "#fefce8",
    c100: "#fef9c3",
    c200: "#fef08a",
    c300: "#fde047",
    c400: "#facc15",
    c500: "#eab308",
    c600: "#ca8a04",
    c700: "#a16207",
    c800: "#854d0e",
    c900: "#713f12",
    c950: "#422006"
  },
  lime: {
    c50: "#f7fee7",
    c100: "#ecfccb",
    c200: "#d9f99d",
    c300: "#bef264",
    c400: "#a3e635",
    c500: "#84cc16",
    c600: "#65a30d",
    c700: "#4d7c0f",
    c800: "#3f6212",
    c900: "#365314",
    c950: "#1a2e05"
  },
  green: {
    c50: "#f0fdf4",
    c100: "#dcfce7",
    c200: "#bbf7d0",
    c300: "#86efac",
    c400: "#4ade80",
    c500: "#22c55e",
    c600: "#16a34a",
    c700: "#15803d",
    c800: "#166534",
    c900: "#14532d",
    c950: "#052e16"
  },
  emerald: {
    c50: "#ecfdf5",
    c100: "#d1fae5",
    c200: "#a7f3d0",
    c300: "#6ee7b7",
    c400: "#34d399",
    c500: "#10b981",
    c600: "#059669",
    c700: "#047857",
    c800: "#065f46",
    c900: "#064e3b",
    c950: "#022c22"
  },
  teal: {
    c50: "#f0fdfa",
    c100: "#ccfbf1",
    c200: "#99f6e4",
    c300: "#5eead4",
    c400: "#2dd4bf",
    c500: "#14b8a6",
    c600: "#0d9488",
    c700: "#0f766e",
    c800: "#115e59",
    c900: "#134e4a",
    c950: "#042f2e"
  },
  cyan: {
    c50: "#ecfeff",
    c100: "#cffafe",
    c200: "#a5f3fc",
    c300: "#67e8f9",
    c400: "#22d3ee",
    c500: "#06b6d4",
    c600: "#0891b2",
    c700: "#0e7490",
    c800: "#155e75",
    c900: "#164e63",
    c950: "#083344"
  },
  sky: {
    c50: "#f0f9ff",
    c100: "#e0f2fe",
    c200: "#bae6fd",
    c300: "#7dd3fc",
    c400: "#38bdf8",
    c500: "#0ea5e9",
    c600: "#0284c7",
    c700: "#0369a1",
    c800: "#075985",
    c900: "#0c4a6e",
    c950: "#082f49"
  },
  blue: {
    c50: "#eff6ff",
    c100: "#dbeafe",
    c200: "#bfdbfe",
    c300: "#93c5fd",
    c400: "#60a5fa",
    c500: "#3b82f6",
    c600: "#2563eb",
    c700: "#1d4ed8",
    c800: "#1e40af",
    c900: "#1e3a8a",
    c950: "#172554"
  },
  indigo: {
    c50: "#eef2ff",
    c100: "#e0e7ff",
    c200: "#c7d2fe",
    c300: "#a5b4fc",
    c400: "#818cf8",
    c500: "#6366f1",
    c600: "#4f46e5",
    c700: "#4338ca",
    c800: "#3730a3",
    c900: "#312e81",
    c950: "#1e1b4b"
  },
  violet: {
    c50: "#f5f3ff",
    c100: "#ede9fe",
    c200: "#ddd6fe",
    c300: "#c4b5fd",
    c400: "#a78bfa",
    c500: "#8b5cf6",
    c600: "#7c3aed",
    c700: "#6d28d9",
    c800: "#5b21b6",
    c900: "#4c1d95",
    c950: "#2e1065"
  },
  purple: {
    c50: "#faf5ff",
    c100: "#f3e8ff",
    c200: "#e9d5ff",
    c300: "#d8b4fe",
    c400: "#c084fc",
    c500: "#a855f7",
    c600: "#9333ea",
    c700: "#7e22ce",
    c800: "#6b21a8",
    c900: "#581c87",
    c950: "#3b0764"
  },
  fuchsia: {
    c50: "#fdf4ff",
    c100: "#fae8ff",
    c200: "#f5d0fe",
    c300: "#f0abfc",
    c400: "#e879f9",
    c500: "#d946ef",
    c600: "#c026d3",
    c700: "#a21caf",
    c800: "#86198f",
    c900: "#701a75",
    c950: "#4a044e"
  },
  pink: {
    c50: "#fdf2f8",
    c100: "#fce7f3",
    c200: "#fbcfe8",
    c300: "#f9a8d4",
    c400: "#f472b6",
    c500: "#ec4899",
    c600: "#db2777",
    c700: "#be185d",
    c800: "#9d174d",
    c900: "#831843",
    c950: "#500724"
  },
  rose: {
    c50: "#fff1f2",
    c100: "#ffe4e6",
    c200: "#fecdd3",
    c300: "#fda4af",
    c400: "#fb7185",
    c500: "#f43f5e",
    c600: "#e11d48",
    c700: "#be123c",
    c800: "#9f1239",
    c900: "#881337",
    c950: "#4c0519"
  }
};
function Dn(t, e) {
  return t + Math.round(e * 255).toString(16).padStart(2, "0");
}
const hn = {
  ".h2o-pdf": {
    lineHeight: "1.5",
    tabSize: "4"
  },
  ".h2o-pdf *": {
    boxSizing: "border-box",
    borderWidth: "0",
    borderStyle: "solid"
  },
  // 1. Change the font styles in all browsers.
  // 2. Remove the margin in Firefox and Safari.
  // 3. Remove default padding in all browsers.
  ".h2o-pdf button, .h2o-pdf input, .h2o-pdf optgroup, .h2o-pdf select, .h2o-pdf textarea": {
    fontFamily: "inherit",
    fontFeatureSettings: "inherit",
    fontVariationSettings: "inherit",
    fontSize: "100%",
    fontWeight: "inherit",
    lineHeight: "inherit",
    letterSpacing: "inherit",
    color: "inherit",
    margin: "0",
    padding: "0"
  },
  // Remove the inheritance of text transform in Edge and Firefox.
  ".h2o-pdf button, .h2o-pdf select": {
    textTransform: "none"
  },
  // 1. Correct the inability to style clickable types in iOS and Safari.
  // 2. Remove default button styles.
  ".h2o-pdf button, .h2o-pdf input:where([type='button']), .h2o-pdf input:where([type='reset']), .h2o-pdf input:where([type='submit'])": {
    "-webkit-appearance": "button",
    backgroundColor: "transparent",
    backgroundImage: "none"
  },
  // Correct the cursor style of increment and decrement buttons in Safari.
  ".h2o-pdf ::-webkit-inner-spin-button, .h2o-pdf ::-webkit-outer-spin-button": {
    height: "auto"
  },
  // 1. Correct the odd appearance in Chrome and Safari.
  // 2. Correct the outline style in Safari.
  ".h2o-pdf input:where([type='search'])": {
    "-webkit-appearance": "textfield",
    outlineOffset: "-2px"
  },
  // Remove the inner padding in Chrome and Safari on macOS.
  ".h2o-pdf ::-webkit-search-decoration": {
    "-webkit-appearance": "none"
  },
  // Prevent resizing textareas horizontally by default.
  ".h2o-pdf textarea": {
    resize: "vertical"
  },
  // 1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)
  // 2. Set the default placeholder color to the user's configured gray 400 color.
  ".h2o-pdf input::placeholder, .h2o-pdf textarea::placeholder": {
    opacity: "1",
    color: "inherit"
  },
  // Set the default cursor for buttons.
  ".h2o-pdf button, .h2o-pdf [role='button']": {
    cursor: "pointer"
  },
  // Make sure disabled buttons don't get the pointer cursor.
  ".h2o-pdf :disabled": {
    cursor: "default"
  },
  ".h2o-pdf-hover-underline:hover": {
    textDecoration: "underline"
  },
  // Remove up/down arrows in number inputs.
  ".h2o-pdf input[type=number]": {
    "-moz-appearance": "textfield"
  },
  ".h2o-pdf input::-webkit-outer-spin-button, .h2o-pdf input::-webkit-inner-spin-button": {
    "-webkit-appearance": "none",
    margin: "0"
  }
}, On = (t) => t.replace(/[A-Z]+(?![a-z])|[A-Z]/g, (e, n) => (n ? "-" : "") + e.toLowerCase());
function Wn(t) {
  Object.assign(hn, t);
}
let Yn = 0;
const Vn = () => `h2o-pdf-${Yn++}`;
function fn(t, e) {
  const n = Vn(), i = {
    [`.h2o-pdf .${n}`]: t
  };
  if (e)
    for (const [s, o] of Object.entries(e))
      i[`.h2o-pdf .${n}${s}`] = o;
  return Wn(i), n;
}
const qn = `
@keyframes h2o-pdf-blink {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0;
  }
}
`;
function Xn() {
  const t = document.createElement("style");
  document.head.appendChild(t);
  const e = t.sheet;
  if (e) {
    e.insertRule(qn, e.cssRules.length);
    for (const [n, i] of Object.entries(hn)) {
      const s = `${n} { ${Object.entries(i).map(([o, r]) => `${On(o)}: ${r}`).join("; ")} }`;
      e.insertRule(s, e.cssRules.length);
    }
  }
}
function z(t, e) {
  const n = e, i = t.style;
  for (const s in n)
    i[s] = n[s];
}
const Gn = Math.sqrt(50), Un = Math.sqrt(10), Zn = Math.sqrt(2);
function _t(t, e, n) {
  const i = (e - t) / Math.max(0, n), s = Math.floor(Math.log10(i)), o = i / Math.pow(10, s), r = o >= Gn ? 10 : o >= Un ? 5 : o >= Zn ? 2 : 1;
  let c, a, h;
  return s < 0 ? (h = Math.pow(10, -s) / r, c = Math.round(t * h), a = Math.round(e * h), c / h < t && ++c, a / h > e && --a, h = -h) : (h = Math.pow(10, s) * r, c = Math.round(t / h), a = Math.round(e / h), c * h < t && ++c, a * h > e && --a), a < c && 0.5 <= n && n < 2 ? _t(t, e, n * 2) : [c, a, h];
}
function Jn(t, e, n) {
  if (e = +e, t = +t, n = +n, !(n > 0))
    return [];
  if (t === e)
    return [t];
  const i = e < t, [s, o, r] = i ? _t(e, t, n) : _t(t, e, n);
  if (!(o >= s))
    return [];
  const c = o - s + 1, a = new Array(c);
  if (i)
    if (r < 0)
      for (let h = 0; h < c; ++h)
        a[h] = (o - h) / -r;
    else
      for (let h = 0; h < c; ++h)
        a[h] = (o - h) * r;
  else if (r < 0)
    for (let h = 0; h < c; ++h)
      a[h] = (s + h) / -r;
  else
    for (let h = 0; h < c; ++h)
      a[h] = (s + h) * r;
  return a;
}
function ne(t, e, n) {
  return e = +e, t = +t, n = +n, _t(t, e, n)[2];
}
function Kn(t, e, n) {
  e = +e, t = +t, n = +n;
  const i = e < t, s = i ? ne(e, t, n) : ne(t, e, n);
  return (i ? -1 : 1) * (s < 0 ? 1 / -s : s);
}
function ue(t, e, n) {
  t.prototype = e.prototype = n, n.constructor = t;
}
function ln(t, e) {
  var n = Object.create(t.prototype);
  for (var i in e)
    n[i] = e[i];
  return n;
}
function bt() {
}
var dt = 0.7, Pt = 1 / dt, it = "\\s*([+-]?\\d+)\\s*", ut = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", L = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", Qn = /^#([0-9a-f]{3,8})$/, ti = new RegExp(`^rgb\\(${it},${it},${it}\\)$`), ei = new RegExp(`^rgb\\(${L},${L},${L}\\)$`), ni = new RegExp(`^rgba\\(${it},${it},${it},${ut}\\)$`), ii = new RegExp(`^rgba\\(${L},${L},${L},${ut}\\)$`), si = new RegExp(`^hsl\\(${ut},${L},${L}\\)$`), oi = new RegExp(`^hsla\\(${ut},${L},${L},${ut}\\)$`), Me = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
ue(bt, pt, {
  copy(t) {
    return Object.assign(new this.constructor(), this, t);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Ce,
  // Deprecated! Use color.formatHex.
  formatHex: Ce,
  formatHex8: ri,
  formatHsl: ci,
  formatRgb: Se,
  toString: Se
});
function Ce() {
  return this.rgb().formatHex();
}
function ri() {
  return this.rgb().formatHex8();
}
function ci() {
  return dn(this).formatHsl();
}
function Se() {
  return this.rgb().formatRgb();
}
function pt(t) {
  var e, n;
  return t = (t + "").trim().toLowerCase(), (e = Qn.exec(t)) ? (n = e[1].length, e = parseInt(e[1], 16), n === 6 ? Ae(e) : n === 3 ? new E(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : n === 8 ? xt(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : n === 4 ? xt(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = ti.exec(t)) ? new E(e[1], e[2], e[3], 1) : (e = ei.exec(t)) ? new E(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = ni.exec(t)) ? xt(e[1], e[2], e[3], e[4]) : (e = ii.exec(t)) ? xt(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = si.exec(t)) ? Ne(e[1], e[2] / 100, e[3] / 100, 1) : (e = oi.exec(t)) ? Ne(e[1], e[2] / 100, e[3] / 100, e[4]) : Me.hasOwnProperty(t) ? Ae(Me[t]) : t === "transparent" ? new E(NaN, NaN, NaN, 0) : null;
}
function Ae(t) {
  return new E(t >> 16 & 255, t >> 8 & 255, t & 255, 1);
}
function xt(t, e, n, i) {
  return i <= 0 && (t = e = n = NaN), new E(t, e, n, i);
}
function ai(t) {
  return t instanceof bt || (t = pt(t)), t ? (t = t.rgb(), new E(t.r, t.g, t.b, t.opacity)) : new E();
}
function ie(t, e, n, i) {
  return arguments.length === 1 ? ai(t) : new E(t, e, n, i ?? 1);
}
function E(t, e, n, i) {
  this.r = +t, this.g = +e, this.b = +n, this.opacity = +i;
}
ue(E, ie, ln(bt, {
  brighter(t) {
    return t = t == null ? Pt : Math.pow(Pt, t), new E(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? dt : Math.pow(dt, t), new E(this.r * t, this.g * t, this.b * t, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new E(K(this.r), K(this.g), K(this.b), zt(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: Re,
  // Deprecated! Use color.formatHex.
  formatHex: Re,
  formatHex8: hi,
  formatRgb: Ie,
  toString: Ie
}));
function Re() {
  return `#${J(this.r)}${J(this.g)}${J(this.b)}`;
}
function hi() {
  return `#${J(this.r)}${J(this.g)}${J(this.b)}${J((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function Ie() {
  const t = zt(this.opacity);
  return `${t === 1 ? "rgb(" : "rgba("}${K(this.r)}, ${K(this.g)}, ${K(this.b)}${t === 1 ? ")" : `, ${t})`}`;
}
function zt(t) {
  return isNaN(t) ? 1 : Math.max(0, Math.min(1, t));
}
function K(t) {
  return Math.max(0, Math.min(255, Math.round(t) || 0));
}
function J(t) {
  return t = K(t), (t < 16 ? "0" : "") + t.toString(16);
}
function Ne(t, e, n, i) {
  return i <= 0 ? t = e = n = NaN : n <= 0 || n >= 1 ? t = e = NaN : e <= 0 && (t = NaN), new j(t, e, n, i);
}
function dn(t) {
  if (t instanceof j)
    return new j(t.h, t.s, t.l, t.opacity);
  if (t instanceof bt || (t = pt(t)), !t)
    return new j();
  if (t instanceof j)
    return t;
  t = t.rgb();
  var e = t.r / 255, n = t.g / 255, i = t.b / 255, s = Math.min(e, n, i), o = Math.max(e, n, i), r = NaN, c = o - s, a = (o + s) / 2;
  return c ? (e === o ? r = (n - i) / c + (n < i) * 6 : n === o ? r = (i - e) / c + 2 : r = (e - n) / c + 4, c /= a < 0.5 ? o + s : 2 - o - s, r *= 60) : c = a > 0 && a < 1 ? 0 : r, new j(r, c, a, t.opacity);
}
function fi(t, e, n, i) {
  return arguments.length === 1 ? dn(t) : new j(t, e, n, i ?? 1);
}
function j(t, e, n, i) {
  this.h = +t, this.s = +e, this.l = +n, this.opacity = +i;
}
ue(j, fi, ln(bt, {
  brighter(t) {
    return t = t == null ? Pt : Math.pow(Pt, t), new j(this.h, this.s, this.l * t, this.opacity);
  },
  darker(t) {
    return t = t == null ? dt : Math.pow(dt, t), new j(this.h, this.s, this.l * t, this.opacity);
  },
  rgb() {
    var t = this.h % 360 + (this.h < 0) * 360, e = isNaN(t) || isNaN(this.s) ? 0 : this.s, n = this.l, i = n + (n < 0.5 ? n : 1 - n) * e, s = 2 * n - i;
    return new E(
      Xt(t >= 240 ? t - 240 : t + 120, s, i),
      Xt(t, s, i),
      Xt(t < 120 ? t + 240 : t - 120, s, i),
      this.opacity
    );
  },
  clamp() {
    return new j(_e(this.h), yt(this.s), yt(this.l), zt(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const t = zt(this.opacity);
    return `${t === 1 ? "hsl(" : "hsla("}${_e(this.h)}, ${yt(this.s) * 100}%, ${yt(this.l) * 100}%${t === 1 ? ")" : `, ${t})`}`;
  }
}));
function _e(t) {
  return t = (t || 0) % 360, t < 0 ? t + 360 : t;
}
function yt(t) {
  return Math.max(0, Math.min(1, t || 0));
}
function Xt(t, e, n) {
  return (t < 60 ? e + (n - e) * t / 60 : t < 180 ? n : t < 240 ? e + (n - e) * (240 - t) / 60 : e) * 255;
}
const pe = (t) => () => t;
function li(t, e) {
  return function (n) {
    return t + n * e;
  };
}
function di(t, e, n) {
  return t = Math.pow(t, n), e = Math.pow(e, n) - t, n = 1 / n, function (i) {
    return Math.pow(t + i * e, n);
  };
}
function ui(t) {
  return (t = +t) == 1 ? un : function (e, n) {
    return n - e ? di(e, n, t) : pe(isNaN(e) ? n : e);
  };
}
function un(t, e) {
  var n = e - t;
  return n ? li(t, n) : pe(isNaN(t) ? e : t);
}
const Pe = function t(e) {
  var n = ui(e);
  function i(s, o) {
    var r = n((s = ie(s)).r, (o = ie(o)).r), c = n(s.g, o.g), a = n(s.b, o.b), h = un(s.opacity, o.opacity);
    return function (f) {
      return s.r = r(f), s.g = c(f), s.b = a(f), s.opacity = h(f), s + "";
    };
  }
  return i.gamma = t, i;
}(1);
function pi(t, e) {
  e || (e = []);
  var n = t ? Math.min(e.length, t.length) : 0, i = e.slice(), s;
  return function (o) {
    for (s = 0; s < n; ++s)
      i[s] = t[s] * (1 - o) + e[s] * o;
    return i;
  };
}
function gi(t) {
  return ArrayBuffer.isView(t) && !(t instanceof DataView);
}
function bi(t, e) {
  var n = e ? e.length : 0, i = t ? Math.min(n, t.length) : 0, s = new Array(i), o = new Array(n), r;
  for (r = 0; r < i; ++r)
    s[r] = ge(t[r], e[r]);
  for (; r < n; ++r)
    o[r] = e[r];
  return function (c) {
    for (r = 0; r < i; ++r)
      o[r] = s[r](c);
    return o;
  };
}
function mi(t, e) {
  var n = /* @__PURE__ */ new Date();
  return t = +t, e = +e, function (i) {
    return n.setTime(t * (1 - i) + e * i), n;
  };
}
function se(t, e) {
  return t = +t, e = +e, function (n) {
    return t * (1 - n) + e * n;
  };
}
function wi(t, e) {
  var n = {}, i = {}, s;
  (t === null || typeof t != "object") && (t = {}), (e === null || typeof e != "object") && (e = {});
  for (s in e)
    s in t ? n[s] = ge(t[s], e[s]) : i[s] = e[s];
  return function (o) {
    for (s in n)
      i[s] = n[s](o);
    return i;
  };
}
var oe = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Gt = new RegExp(oe.source, "g");
function xi(t) {
  return function () {
    return t;
  };
}
function yi(t) {
  return function (e) {
    return t(e) + "";
  };
}
function vi(t, e) {
  var n = oe.lastIndex = Gt.lastIndex = 0, i, s, o, r = -1, c = [], a = [];
  for (t = t + "", e = e + ""; (i = oe.exec(t)) && (s = Gt.exec(e));)
    (o = s.index) > n && (o = e.slice(n, o), c[r] ? c[r] += o : c[++r] = o), (i = i[0]) === (s = s[0]) ? c[r] ? c[r] += s : c[++r] = s : (c[++r] = null, a.push({ i: r, x: se(i, s) })), n = Gt.lastIndex;
  return n < e.length && (o = e.slice(n), c[r] ? c[r] += o : c[++r] = o), c.length < 2 ? a[0] ? yi(a[0].x) : xi(e) : (e = a.length, function (h) {
    for (var f = 0, l; f < e; ++f)
      c[(l = a[f]).i] = l.x(h);
    return c.join("");
  });
}
function ge(t, e) {
  var n = typeof e, i;
  return e == null || n === "boolean" ? pe(e) : (n === "number" ? se : n === "string" ? (i = pt(e)) ? (e = i, Pe) : vi : e instanceof pt ? Pe : e instanceof Date ? mi : gi(e) ? pi : Array.isArray(e) ? bi : typeof e.valueOf != "function" && typeof e.toString != "function" || isNaN(e) ? wi : se)(t, e);
}
function ki(t, e) {
  return t = +t, e = +e, function (n) {
    return Math.round(t * (1 - n) + e * n);
  };
}
function Mi(t) {
  return Math.abs(t = Math.round(t)) >= 1e21 ? t.toLocaleString("en").replace(/,/g, "") : t.toString(10);
}
function $t(t, e) {
  if ((n = (t = e ? t.toExponential(e - 1) : t.toExponential()).indexOf("e")) < 0)
    return null;
  var n, i = t.slice(0, n);
  return [
    i.length > 1 ? i[0] + i.slice(2) : i,
    +t.slice(n + 1)
  ];
}
function st(t) {
  return t = $t(Math.abs(t)), t ? t[1] : NaN;
}
function Ci(t, e) {
  return function (n, i) {
    for (var s = n.length, o = [], r = 0, c = t[0], a = 0; s > 0 && c > 0 && (a + c + 1 > i && (c = Math.max(1, i - a)), o.push(n.substring(s -= c, s + c)), !((a += c + 1) > i));)
      c = t[r = (r + 1) % t.length];
    return o.reverse().join(e);
  };
}
function Si(t) {
  return function (e) {
    return e.replace(/[0-9]/g, function (n) {
      return t[+n];
    });
  };
}
var Ai = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function Et(t) {
  if (!(e = Ai.exec(t)))
    throw new Error("invalid format: " + t);
  var e;
  return new be({
    fill: e[1],
    align: e[2],
    sign: e[3],
    symbol: e[4],
    zero: e[5],
    width: e[6],
    comma: e[7],
    precision: e[8] && e[8].slice(1),
    trim: e[9],
    type: e[10]
  });
}
Et.prototype = be.prototype;
function be(t) {
  this.fill = t.fill === void 0 ? " " : t.fill + "", this.align = t.align === void 0 ? ">" : t.align + "", this.sign = t.sign === void 0 ? "-" : t.sign + "", this.symbol = t.symbol === void 0 ? "" : t.symbol + "", this.zero = !!t.zero, this.width = t.width === void 0 ? void 0 : +t.width, this.comma = !!t.comma, this.precision = t.precision === void 0 ? void 0 : +t.precision, this.trim = !!t.trim, this.type = t.type === void 0 ? "" : t.type + "";
}
be.prototype.toString = function () {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function Ri(t) {
  t:
  for (var e = t.length, n = 1, i = -1, s; n < e; ++n)
    switch (t[n]) {
      case ".":
        i = s = n;
        break;
      case "0":
        i === 0 && (i = n), s = n;
        break;
      default:
        if (!+t[n])
          break t;
        i > 0 && (i = 0);
        break;
    }
  return i > 0 ? t.slice(0, i) + t.slice(s + 1) : t;
}
var pn;
function Ii(t, e) {
  var n = $t(t, e);
  if (!n)
    return t + "";
  var i = n[0], s = n[1], o = s - (pn = Math.max(-8, Math.min(8, Math.floor(s / 3))) * 3) + 1, r = i.length;
  return o === r ? i : o > r ? i + new Array(o - r + 1).join("0") : o > 0 ? i.slice(0, o) + "." + i.slice(o) : "0." + new Array(1 - o).join("0") + $t(t, Math.max(0, e + o - 1))[0];
}
function ze(t, e) {
  var n = $t(t, e);
  if (!n)
    return t + "";
  var i = n[0], s = n[1];
  return s < 0 ? "0." + new Array(-s).join("0") + i : i.length > s + 1 ? i.slice(0, s + 1) + "." + i.slice(s + 1) : i + new Array(s - i.length + 2).join("0");
}
const $e = {
  "%": (t, e) => (t * 100).toFixed(e),
  b: (t) => Math.round(t).toString(2),
  c: (t) => t + "",
  d: Mi,
  e: (t, e) => t.toExponential(e),
  f: (t, e) => t.toFixed(e),
  g: (t, e) => t.toPrecision(e),
  o: (t) => Math.round(t).toString(8),
  p: (t, e) => ze(t * 100, e),
  r: ze,
  s: Ii,
  X: (t) => Math.round(t).toString(16).toUpperCase(),
  x: (t) => Math.round(t).toString(16)
};
function Ee(t) {
  return t;
}
var Be = Array.prototype.map, Fe = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function Ni(t) {
  var e = t.grouping === void 0 || t.thousands === void 0 ? Ee : Ci(Be.call(t.grouping, Number), t.thousands + ""), n = t.currency === void 0 ? "" : t.currency[0] + "", i = t.currency === void 0 ? "" : t.currency[1] + "", s = t.decimal === void 0 ? "." : t.decimal + "", o = t.numerals === void 0 ? Ee : Si(Be.call(t.numerals, String)), r = t.percent === void 0 ? "%" : t.percent + "", c = t.minus === void 0 ? "−" : t.minus + "", a = t.nan === void 0 ? "NaN" : t.nan + "";
  function h(l) {
    l = Et(l);
    var u = l.fill, p = l.align, d = l.sign, b = l.symbol, k = l.zero, S = l.width, x = l.comma, v = l.precision, B = l.trim, A = l.type;
    A === "n" ? (x = !0, A = "g") : $e[A] || (v === void 0 && (v = 12), B = !0, A = "g"), (k || u === "0" && p === "=") && (k = !0, u = "0", p = "=");
    var T = b === "$" ? n : b === "#" && /[boxX]/.test(A) ? "0" + A.toLowerCase() : "", F = b === "$" ? i : /[%p]/.test(A) ? r : "", H = $e[A], et = /[defgprs%]/.test(A);
    v = v === void 0 ? 6 : /[gprs]/.test(A) ? Math.max(1, Math.min(21, v)) : Math.max(0, Math.min(20, v));
    function Y(y) {
      var D = T, $ = F, O, nt, G;
      if (A === "c")
        $ = H(y) + $, y = "";
      else {
        y = +y;
        var ct = y < 0 || 1 / y < 0;
        if (y = isNaN(y) ? a : H(Math.abs(y), v), B && (y = Ri(y)), ct && +y == 0 && d !== "+" && (ct = !1), D = (ct ? d === "(" ? d : c : d === "-" || d === "(" ? "" : d) + D, $ = (A === "s" ? Fe[8 + pn / 3] : "") + $ + (ct && d === "(" ? ")" : ""), et) {
          for (O = -1, nt = y.length; ++O < nt;)
            if (G = y.charCodeAt(O), 48 > G || G > 57) {
              $ = (G === 46 ? s + y.slice(O + 1) : y.slice(O)) + $, y = y.slice(0, O);
              break;
            }
        }
      }
      x && !k && (y = e(y, 1 / 0));
      var wt = D.length + y.length + $.length, W = wt < S ? new Array(S - wt + 1).join(u) : "";
      switch (x && k && (y = e(W + y, W.length ? S - $.length : 1 / 0), W = ""), p) {
        case "<":
          y = D + y + $ + W;
          break;
        case "=":
          y = D + W + y + $;
          break;
        case "^":
          y = W.slice(0, wt = W.length >> 1) + D + y + $ + W.slice(wt);
          break;
        default:
          y = W + D + y + $;
          break;
      }
      return o(y);
    }
    return Y.toString = function () {
      return l + "";
    }, Y;
  }
  function f(l, u) {
    var p = h((l = Et(l), l.type = "f", l)), d = Math.max(-8, Math.min(8, Math.floor(st(u) / 3))) * 3, b = Math.pow(10, -d), k = Fe[8 + d / 3];
    return function (S) {
      return p(b * S) + k;
    };
  }
  return {
    format: h,
    formatPrefix: f
  };
}
var vt, gn, bn;
_i({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function _i(t) {
  return vt = Ni(t), gn = vt.format, bn = vt.formatPrefix, vt;
}
function Pi(t) {
  return Math.max(0, -st(Math.abs(t)));
}
function zi(t, e) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(st(e) / 3))) * 3 - st(Math.abs(t)));
}
function $i(t, e) {
  return t = Math.abs(t), e = Math.abs(e) - t, Math.max(0, st(e) - st(t)) + 1;
}
function Ei(t, e) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      typeof t == "function" ? this.interpolator(t) : this.range(t);
      break;
    }
    default: {
      this.domain(t), typeof e == "function" ? this.interpolator(e) : this.range(e);
      break;
    }
  }
  return this;
}
function mn(t) {
  return t;
}
function Bi(t, e, n, i) {
  var s = Kn(t, e, n), o;
  switch (i = Et(i ?? ",f"), i.type) {
    case "s": {
      var r = Math.max(Math.abs(t), Math.abs(e));
      return i.precision == null && !isNaN(o = zi(s, r)) && (i.precision = o), bn(i, r);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      i.precision == null && !isNaN(o = $i(s, Math.max(Math.abs(t), Math.abs(e)))) && (i.precision = o - (i.type === "e"));
      break;
    }
    case "f":
    case "%": {
      i.precision == null && !isNaN(o = Pi(s)) && (i.precision = o - (i.type === "%") * 2);
      break;
    }
  }
  return gn(i);
}
function Fi(t) {
  var e = t.domain;
  return t.ticks = function (n) {
    var i = e();
    return Jn(i[0], i[i.length - 1], n ?? 10);
  }, t.tickFormat = function (n, i) {
    var s = e();
    return Bi(s[0], s[s.length - 1], n ?? 10, i);
  }, t.nice = function (n) {
    n == null && (n = 10);
    var i = e(), s = 0, o = i.length - 1, r = i[s], c = i[o], a, h, f = 10;
    for (c < r && (h = r, r = c, c = h, h = s, s = o, o = h); f-- > 0;) {
      if (h = ne(r, c, n), h === a)
        return i[s] = r, i[o] = c, e(i);
      if (h > 0)
        r = Math.floor(r / h) * h, c = Math.ceil(c / h) * h;
      else if (h < 0)
        r = Math.ceil(r * h) / h, c = Math.floor(c * h) / h;
      else
        break;
      a = h;
    }
    return t;
  }, t;
}
function ji() {
  var t = 0, e = 1, n, i, s, o, r = mn, c = !1, a;
  function h(l) {
    return l == null || isNaN(l = +l) ? a : r(s === 0 ? 0.5 : (l = (o(l) - n) * s, c ? Math.max(0, Math.min(1, l)) : l));
  }
  h.domain = function (l) {
    return arguments.length ? ([t, e] = l, n = o(t = +t), i = o(e = +e), s = n === i ? 0 : 1 / (i - n), h) : [t, e];
  }, h.clamp = function (l) {
    return arguments.length ? (c = !!l, h) : c;
  }, h.interpolator = function (l) {
    return arguments.length ? (r = l, h) : r;
  };
  function f(l) {
    return function (u) {
      var p, d;
      return arguments.length ? ([p, d] = u, r = l(p, d), h) : [r(0), r(1)];
    };
  }
  return h.range = f(ge), h.rangeRound = f(ki), h.unknown = function (l) {
    return arguments.length ? (a = l, h) : a;
  }, function (l) {
    return o = l, n = l(t), i = l(e), s = n === i ? 0 : 1 / (i - n), h;
  };
}
function Li(t, e) {
  return e.domain(t.domain()).interpolator(t.interpolator()).clamp(t.clamp()).unknown(t.unknown());
}
function me() {
  var t = Fi(ji()(mn));
  return t.copy = function () {
    return Li(t, me());
  }, Ei.apply(t, arguments);
}
function Ht(t) {
  for (var e = t.length / 6 | 0, n = new Array(e), i = 0; i < e;)
    n[i] = "#" + t.slice(i * 6, ++i * 6);
  return n;
}
function Ti(t) {
  return t = Math.max(0, Math.min(1, t)), "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67))))))) + ")";
}
function Dt(t) {
  var e = t.length;
  return function (n) {
    return t[Math.max(0, Math.min(e - 1, Math.floor(n * e)))];
  };
}
Dt(Ht("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
Dt(Ht("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
Dt(Ht("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
var Hi = Dt(Ht("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
function ft(t, e, n) {
  this.k = t, this.x = e, this.y = n;
}
ft.prototype = {
  constructor: ft,
  scale: function (t) {
    return t === 1 ? this : new ft(this.k * t, this.x, this.y);
  },
  translate: function (t, e) {
    return t === 0 & e === 0 ? this : new ft(this.k, this.x + this.k * t, this.y + this.k * e);
  },
  apply: function (t) {
    return [t[0] * this.k + this.x, t[1] * this.k + this.y];
  },
  applyX: function (t) {
    return t * this.k + this.x;
  },
  applyY: function (t) {
    return t * this.k + this.y;
  },
  invert: function (t) {
    return [(t[0] - this.x) / this.k, (t[1] - this.y) / this.k];
  },
  invertX: function (t) {
    return (t - this.x) / this.k;
  },
  invertY: function (t) {
    return (t - this.y) / this.k;
  },
  rescaleX: function (t) {
    return t.copy().domain(t.range().map(this.invertX, this).map(t.invert, t));
  },
  rescaleY: function (t) {
    return t.copy().domain(t.range().map(this.invertY, this).map(t.invert, t));
  },
  toString: function () {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
ft.prototype;
const Di = {
  ellipsisCircle: "M8.625 12a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Zm0 0H8.25m4.125 0a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Zm0 0H12m4.125 0a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Zm0 0h-.375M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
};
function Oi(t) {
  return `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
<path stroke-linecap="round" stroke-linejoin="round" d="${Di[t]}" />
</svg>`;
}
const Wi = `
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M16.5 10.5V6.75a4.5 4.5 0 1 0-9 0v3.75m-.75 11.25h10.5a2.25 2.25 0 0 0 2.25-2.25v-6.75a2.25 2.25 0 0 0-2.25-2.25H6.75a2.25 2.25 0 0 0-2.25 2.25v6.75a2.25 2.25 0 0 0 2.25 2.25Z" />
</svg>
`, Yi = `
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.5 10.5V6.75a4.5 4.5 0 1 1 9 0v3.75M3.75 21.75h10.5a2.25 2.25 0 0 0 2.25-2.25v-6.75a2.25 2.25 0 0 0-2.25-2.25H3.75a2.25 2.25 0 0 0-2.25 2.25v6.75a2.25 2.25 0 0 0 2.25 2.25Z" />
</svg>
`, wn = `
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="m4.5 15.75 7.5-7.5 7.5 7.5" />
</svg>
`, we = `
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" />
</svg>
`, Vi = `
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="m8.25 4.5 7.5 7.5-7.5 7.5" />
</svg>
`, xn = `
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" />
</svg>
`, qi = `
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 6.75h12M8.25 12h12m-12 5.25h12M3.75 6.75h.007v.008H3.75V6.75Zm.375 0a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0ZM3.75 12h.007v.008H3.75V12Zm.375 0a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Zm-.375 5.25h.007v.008H3.75v-.008Zm.375 0a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Z" />
</svg>
`, Xi = `
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
</svg>
`, yn = `
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h14" />
</svg>
`, Gi = `
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607ZM10.5 7.5v6m3-3h-6" />
</svg>
`, Ui = `
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607ZM13.5 10.5h-6" />
</svg>
`, Zi = `
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 9V4.5M9 9H4.5M9 9 3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9h4.5M15 9V4.5M15 9l5.25-5.25M15 15h4.5M15 15v4.5m0-4.5 5.25 5.25" />
</svg>
`, Ji = `
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607Z" />
</svg>
`, Z = (t) => t * 8, M = (t) => `${Z(t)}px`, g = (t) => `${t}px`;
function q(t, e, n = !1) {
  const i = document.createElement("canvas"), s = window.devicePixelRatio || 1;
  i.style.position = "absolute", i.style.width = g(t), i.style.height = g(e), i.width = t * s, i.height = e * s;
  const o = i.getContext("2d", { willReadFrequently: n });
  if (!o)
    throw new Error("Failed to create canvas context");
  return s !== 1 && o.scale(s, s), { canvas: i, g: o, dpr: s, width: t, height: e };
}
function xe(t, e, n, i = !1) {
  const s = q(t, e, i);
  return z(s.canvas, n), s;
}
function Ki(t, e) {
  let n = 0;
  return (...i) => {
    window.clearTimeout(n), n = window.setTimeout(() => e(...i), t);
  };
}
const vn = (t, e) => window.setTimeout(e, t);
function Ot(t, e) {
  let n = !1, i = null;
  const s = () => {
    i ? (e(...i), i = null, window.setTimeout(s, t)) : n = !1;
  };
  return (...o) => {
    if (n) {
      i = o;
      return;
    }
    e(...o), n = !0, window.setTimeout(s, t);
  };
}
function m(t, ...e) {
  const n = document.createElement("div");
  if (z(n, t), e)
    for (const i of e)
      i && n.appendChild(typeof i == "string" ? document.createTextNode(i) : i);
  return n;
}
function Qi(t, e) {
  const n = fn(t, e);
  return (i, ...s) => {
    const o = m(i, ...s);
    return o.className = n, o;
  };
}
function kn(t) {
  for (; t.firstChild;)
    t.removeChild(t.firstChild);
}
function ts(t, e) {
  kn(t), t.appendChild(e);
}
function Bt(t, e) {
  kn(t);
  for (const n of e)
    n && t.appendChild(n);
}
let kt = -1;
function es() {
  if (kt > -1)
    return kt;
  const t = m({
    position: "absolute",
    left: g(-50),
    top: g(-50),
    width: g(50),
    height: g(50),
    overflow: "auto"
  }), e = m({
    width: g(5),
    height: g(100)
  });
  return t.appendChild(e), document.body.appendChild(t), kt = t.offsetWidth - t.clientWidth + 1, document.body.removeChild(t), kt;
}
function Ft(t, e) {
  const n = m({
    width: g(e),
    height: g(e)
  });
  return n.innerHTML = t, n;
}
function _(t, e, n, i) {
  const s = document.createElement("button");
  return s.title = n, z(s, {
    border: "none",
    padding: g(4)
  }), s.appendChild(Ft(t, e)), s.addEventListener("click", i), s;
}
function Mn(t) {
  const e = m({
    fontSize: g(12),
    userSelect: "none",
    padding: "0 4px"
  });
  return e.textContent = t, e;
}
class ns {
  root;
  #t;
  #e;
  #n;
  #i;
  constructor(e, n, i, s, o, r, c, a) {
    this.#i = s, this.#t = o, this.#e = r, this.#n = a;
    const h = document.createElement("input");
    h.type = "number", h.title = e, h.value = String(s), h.min = String(o), h.max = String(r), h.step = String(c), z(h, {
      fontSize: g(12),
      textAlign: "center",
      width: g(n),
      height: g(i)
    }), h.addEventListener("input", () => {
      let f = parseInt(h.value);
      isNaN(f) || this.setValue(f);
    }), this.root = h;
  }
  setValue(e, n) {
    e = Math.max(this.#t, Math.min(this.#e, e)), this.#i !== e && (this.#i = e, n || this.#n(this.#i));
    const i = String(this.#i);
    this.root.value !== i && (this.root.value = i);
  }
  scroll(e) {
    this.setValue(this.#i + e);
  }
}
const je = me(Ti).domain([1, 0]), Le = me(Hi).domain([1, 0]);
function is() {
  let t = [];
  return {
    on: (e) => {
      t.push(e);
    },
    fire: (e) => {
      for (const n of t)
        n(e);
    }
  };
}
class ss {
  #t = null;
  defer(e, n) {
    this.cancel(), this.#t = window.setTimeout(n, e * 1e3);
  }
  now(e) {
    this.defer(1e-3, e);
  }
  cancel() {
    this.#t && (window.clearTimeout(this.#t), this.#t = null);
  }
}
function os(t, e) {
  z(t, { cursor: "pointer" }), t.addEventListener("click", e);
}
const Wt = (t) => z(t, { display: "block" }), Yt = (t) => z(t, { display: "none" });
function jt(t, e) {
  Yt(t), Wt(e);
}
var N = /* @__PURE__ */ ((t) => (t[t.Delete = 0] = "Delete", t[t.Insert = 1] = "Insert", t[t.Replace = 2] = "Replace", t))(N || {});
const Te = 256, He = w.rose.c600, De = w.rose.c200, Oe = w.indigo.c600, We = w.indigo.c200, Ut = (t) => t === "Accepted" ? w.green.c300 : w.red.c400;
function rs(t, e) {
  const n = document.createElement("button");
  return n.title = t, z(n, {
    color: w.zinc.c500,
    border: "none"
  }), n.appendChild(Ft(Oi("ellipsisCircle"), 16)), n.addEventListener("click", e), n;
}
const cs = Qi(
  {
    padding: M(1),
    background: w.zinc.c100,
    marginTop: M(1),
    marginBottom: M(1),
    border: `1px solid ${w.zinc.c300}`,
    borderRadius: g(4),
    fontSize: g(12)
  },
  {
    ":hover": {
      border: `1px solid ${w.zinc.c400}`
    },
    " .mute": {
      display: "none"
    },
    ":hover .mute": {
      display: "block"
    },
    ":hover .unmute": {
      display: "none"
    }
  }
), Mt = (t) => t.split(/\s+/).length, Ct = (t) => t.map(({ c: e }) => e === `
` || e === "	" ? " " : e).join(""), Zt = (t, e) => m(
  {
    textTransform: "uppercase",
    color: w.zinc.c800,
    flexGrow: "1"
  },
  `${t + 1}. ${e}`
);
function U(t, e) {
  const n = m({ marginLeft: g(4), color: e }, t);
  return n.classList.add("unmute"), n;
}
function as(t, e) {
  if (t.length <= e)
    return t;
  const n = t.slice(0, e);
  if (t[e] === " ")
    return n;
  const i = n.lastIndexOf(" ");
  return i === -1 ? n : n.slice(0, i);
}
const hs = "(less...)", Ye = " (more...)";
function St(t, e) {
  const n = as(t, Te), i = m(
    {
      display: "inline",
      backgroundColor: e
    },
    n
  ), s = t.length > Te ? m(
    {
      display: "inline",
      marginLeft: g(4),
      color: w.zinc.c800,
      cursor: "pointer"
    },
    Ye
  ) : null;
  if (s) {
    let o = !1;
    s.addEventListener("click", (r) => {
      r.stopPropagation(), o = !o, o ? (i.textContent = t, s.textContent = hs) : (i.textContent = n, s.textContent = Ye);
    });
  }
  return m({}, i, s);
}
function fs(t, e, n, i, s, o) {
  const r = [], c = [], a = rs("More", (f) => {
    f.stopPropagation(), o(t, e);
  });
  switch (a.classList.add("mute"), t.t) {
    case N.Delete:
      {
        r.push(Zt(e, "Deleted"));
        const f = Ct(t.chars), l = Mt(f);
        r.push(U(n, Ut(n)), U(`-${l}`, He), a), c.push(St(f, De));
      }
      break;
    case N.Insert:
      {
        r.push(Zt(e, "Inserted"));
        const f = Ct(t.chars), l = Mt(f);
        r.push(U(n, Ut(n)), U(`+${l}`, Oe), a), c.push(St(f, We));
      }
      break;
    case N.Replace:
      {
        r.push(Zt(e, "Replaced"));
        const f = Ct(t.delete.chars), l = Mt(f), u = Ct(t.insert.chars), p = Mt(u);
        r.push(
          U(n, Ut(n)),
          U(`-${l}`, He),
          U(`+${p}`, Oe),
          a
        ), c.push(
          St(f, De),
          St(u, We)
        );
      }
      break;
  }
  const h = cs(
    {},
    m(
      {
        display: "flex",
        height: M(2),
        marginBottom: M(1)
      },
      ...r
    ),
    m(
      {
        overflowWrap: "anywhere",
        // whiteSpace: 'pre-wrap',
        lineHeight: g(15),
        color: w.zinc.c100
      },
      ...c
    )
  );
  return h.addEventListener("click", () => i(t)), h.addEventListener("mouseenter", () => s(t)), h;
}
class ls {
  constructor(e, n, i, s, o, r, c, a, h, f, l) {
    this.left = n, this.top = i, this.width = s, this.height = o, this.doc1 = r, this.doc2 = c, this.diff = a, this.changeLog = h, this.onSelect = f, this.onHide = l;
    const u = m(
      {
        position: "absolute",
        left: "0",
        top: "0",
        right: "0",
        height: g(e.toolbarHeight),
        display: "flex",
        alignItems: "center",
        border: `1px solid ${w.zinc.c300}`,
        boxSizing: "border-box",
        paddingLeft: M(1),
        paddingRight: M(1),
        background: e.toolbarColor,
        color: e.toolbarTextColor,
        fontSize: g(12)
      },
      m(
        {
          flexGrow: "1"
        },
        "Changes"
      ),
      _(yn, 16, "Close", l)
    ), p = async (x, v) => {
      switch (x.t) {
        case N.Delete:
          await this.doc1.selectChars(x.chars, v);
          break;
        case N.Insert:
          await this.doc2.selectChars(x.chars, v);
          break;
        case N.Replace:
          await this.doc1.selectChars(x.delete.chars, v), await this.doc2.selectChars(x.insert.chars, v);
          break;
      }
    }, d = async (x) => {
      switch (x.t) {
        case N.Delete:
          await this.doc1.hoverChars(x.chars);
          break;
        case N.Insert:
          await this.doc2.hoverChars(x.chars);
          break;
        case N.Replace:
          await this.doc1.hoverChars(x.delete.chars), await this.doc2.hoverChars(x.insert.chars);
          break;
      }
    }, b = h.normalized.map((x) => x.status || ""), k = a.normalized.map((x, v) => {
      const B = b[v], A = fs(
        x,
        v,
        B,
        async (T) => {
          const F = S.getBoundingClientRect(), et = A.getBoundingClientRect().top - F.top;
          await p(T, et);
        },
        d,
        f
      );
      return A;
    }), S = m(
      {
        position: "absolute",
        left: g(0),
        top: g(e.toolbarHeight),
        right: g(0),
        height: g(o - e.toolbarHeight),
        overflow: "auto"
      },
      ...k
    );
    this.root = m(
      {
        position: "absolute",
        left: g(n),
        top: g(i),
        width: g(s),
        height: g(o),
        backgroundColor: w.zinc.c100
      },
      u,
      S
    );
  }
  root;
}
class ds {
  constructor(e, n, i) {
    this.opts = e, this.width = n, this.height = i, this.base = q(n, i), this.base.g.fillStyle = "#fff", this.overlay = xe(n, i, {
      opacity: `${e.highlightOverlayOpacity}`
    }), this.root = m(
      {
        position: "absolute",
        top: g(e.toolbarHeight),
        width: g(n),
        height: g(i),
        background: "rgba(0,0,0,.4)",
        display: "none",
        opacity: "0",
        transition: `opacity ${e.lensFadeInterval}s`
      },
      this.base.canvas,
      this.overlay.canvas
    );
  }
  root;
  base;
  overlay;
  #t = new ss();
  #e = null;
  async show(e) {
    this.#e = e, e ? (await e.copy(this), this.#n()) : this.#n();
  }
  #n() {
    this.#e ? (this.root.style.display = "block", this.#t.now(() => {
      this.root.style.opacity = "1";
    })) : (this.root.style.opacity = "0", this.#t.defer(this.opts.lensFadeInterval, () => {
      this.root.style.display = "none";
    }));
  }
}
const Ve = {
  width: M(2),
  height: M(2),
  cursor: "pointer"
};
class ye {
  root;
  entries;
  #t;
  #e = !1;
  depth;
  constructor(e, n, i) {
    this.depth = n;
    const s = m({
      padding: g(2),
      userSelect: "none",
      cursor: "pointer",
      whiteSpace: "nowrap",
      overflow: "hidden",
      textOverflow: "ellipsis",
      flexGrow: "1",
      color: w.zinc.c800
    });
    s.className = "h2o-pdf-hover-underline", s.textContent = e.heading.text.trim(), s.addEventListener("click", (a) => {
      a.stopPropagation(), i(this.root, e);
    });
    const o = m({
      color: w.zinc.c400,
      fontSize: g(12)
    });
    o.textContent = us(e);
    const r = {
      paddingLeft: M(n * 2),
      display: "flex",
      alignItems: "center"
    };
    if (e.sections.length > 0) {
      const a = e.sections.map((p) => new ye(p, n + 1, i)), h = m({}, ...a.map((p) => p.root)), f = Ft(we, 16);
      z(f, Ve);
      const l = Ft(Vi, 16);
      z(l, Ve);
      const u = m(r, f, l, s, o);
      os(u, () => this.toggle()), this.#t = {
        expandedIcon: f,
        collapsedIcon: l,
        children: h
      }, this.entries = a, this.root = m({}, u, h);
    } else {
      z(s, { paddingLeft: M(2) });
      const a = m(r, s, o);
      this.#t = null, this.entries = [], this.root = m({}, a);
    }
    this.expand();
  }
  toggle() {
    this.#e ? this.collapse() : this.expand();
  }
  get isExpanded() {
    return this.#e;
  }
  expand() {
    if (this.#t) {
      this.#e = !0;
      const { collapsedIcon: e, expandedIcon: n, children: i } = this.#t;
      Wt(i), jt(e, n);
    }
  }
  collapse() {
    if (this.#t) {
      this.#e = !1;
      const { collapsedIcon: e, expandedIcon: n, children: i } = this.#t;
      Yt(i), jt(n, e);
    }
  }
}
function us(t) {
  const e = t.nodes.find((n) => n.t === "t");
  return e ? (e.page.id + 1).toString() : "";
}
class ps {
  #t = !1;
  entries;
  root;
  constructor(e, n) {
    const i = Z(4), s = m(
      {
        position: "absolute",
        left: "0",
        top: "0",
        right: "0",
        height: g(i),
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        padding: g(4),
        borderBottom: "1px solid #ddd",
        paddingLeft: M(1),
        paddingRight: M(1),
        background: "#f4f4f5"
      },
      m(
        {
          display: "flex",
          alignItems: "center"
        },
        Mn("Outline"),
        _(Xi, 16, "Unfold", () => this.unfold()),
        _(yn, 16, "Fold", () => this.fold())
      ),
      _(xn, 16, "Close", () => this.hide())
    ), o = e.sections.filter((h) => !h.parent).map(
      (h) => new ye(h, 0, (f, l) => {
        const u = r.getBoundingClientRect(), d = f.getBoundingClientRect().top - u.top + i;
        n(l, d);
      })
    ), r = m(
      {
        position: "absolute",
        fontSize: g(14),
        left: "0",
        top: M(4),
        bottom: "0",
        right: "0",
        overflow: "auto",
        background: "#ffffff",
        padding: M(1)
      },
      ...o.map((h) => h.root)
    ), c = m(
      {
        position: "absolute",
        display: "flex",
        left: "0",
        top: "0",
        bottom: "0",
        width: M(50),
        background: "#fff"
      },
      s,
      r
    ), a = m({
      position: "absolute",
      inset: "0",
      background: "rgba(0,0,0,.25)"
    });
    a.addEventListener("click", () => this.hide()), this.entries = o, this.root = m(
      {
        position: "absolute",
        display: this.#t ? "block" : "none",
        inset: `${M(4.5)} 0 0 0`
      },
      a,
      c
    );
  }
  toggle() {
    this.#t ? this.hide() : this.show();
  }
  show() {
    this.#t = !0, Wt(this.root);
  }
  hide() {
    this.#t = !1, Yt(this.root);
  }
  fold() {
    const e = this.#e(this.entries, 0);
    this.#n(this.entries, e - 1);
  }
  unfold() {
    const e = this.#e(this.entries, 0);
    this.#n(this.entries, e + 1);
  }
  #e(e, n) {
    for (const i of e)
      i.isExpanded && (n = Math.max(n, i.depth + 1)), n = Math.max(n, this.#e(i.entries, n));
    return n;
  }
  #n(e, n) {
    for (const i of e)
      i.depth < n ? i.expand() : i.collapse(), this.#n(i.entries, n);
  }
}
var R;
function It(t) {
  return typeof t < "u" ? t : !0;
}
function qe(t) {
  const e = Array(t);
  for (let n = 0; n < t; n++)
    e[n] = C();
  return e;
}
function C() {
  return /* @__PURE__ */ Object.create(null);
}
function gs(t, e) {
  return e.length - t.length;
}
function P(t) {
  return typeof t == "string";
}
function X(t) {
  return typeof t == "object";
}
function ve(t) {
  return typeof t == "function";
}
function Cn(t, e) {
  var n = bs;
  if (t && (e && (t = Nt(t, e)), this.H && (t = Nt(t, this.H)), this.J && 1 < t.length && (t = Nt(t, this.J)), n || n === "")) {
    if (e = t.split(n), this.filter) {
      t = this.filter, n = e.length;
      const i = [];
      for (let s = 0, o = 0; s < n; s++) {
        const r = e[s];
        r && !t[r] && (i[o++] = r);
      }
      t = i;
    } else
      t = e;
    return t;
  }
  return t;
}
const bs = /[\p{Z}\p{S}\p{P}\p{C}]+/u, ms = /[\u0300-\u036f]/g;
function Xe(t, e) {
  const n = Object.keys(t), i = n.length, s = [];
  let o = "", r = 0;
  for (let c = 0, a, h; c < i; c++)
    a = n[c], (h = t[a]) ? (s[r++] = I(e ? "(?!\\b)" + a + "(\\b|_)" : a), s[r++] = h) : o += (o ? "|" : "") + a;
  return o && (s[r++] = I(e ? "(?!\\b)(" + o + ")(\\b|_)" : "(" + o + ")"), s[r] = ""), s;
}
function Nt(t, e) {
  for (let n = 0, i = e.length; n < i && (t = t.replace(e[n], e[n + 1]), t); n += 2)
    ;
  return t;
}
function I(t) {
  return new RegExp(t, "g");
}
function Sn(t) {
  let e = "", n = "";
  for (let i = 0, s = t.length, o; i < s; i++)
    (o = t[i]) !== n && (e += n = o);
  return e;
}
var ws = { encode: An, F: !1, G: "" };
function An(t) {
  return Cn.call(this, ("" + t).toLowerCase(), !1);
}
const Rn = {}, tt = {};
function In(t) {
  at(t, "add"), at(t, "append"), at(t, "search"), at(t, "update"), at(t, "remove");
}
function at(t, e) {
  t[e + "Async"] = function () {
    const n = this, i = arguments;
    var s = i[i.length - 1];
    let o;
    return ve(s) && (o = s, delete i[i.length - 1]), s = new Promise(function (r) {
      setTimeout(function () {
        n.async = !0;
        const c = n[e].apply(n, i);
        n.async = !1, r(c);
      });
    }), o ? (s.then(o), this) : s;
  };
}
function Nn(t, e, n, i) {
  const s = t.length;
  let o = [], r, c, a = 0;
  i && (i = []);
  for (let h = s - 1; 0 <= h; h--) {
    const f = t[h], l = f.length, u = C();
    let p = !r;
    for (let d = 0; d < l; d++) {
      const b = f[d], k = b.length;
      if (k)
        for (let S = 0, x, v; S < k; S++)
          if (v = b[S], r) {
            if (r[v]) {
              if (!h) {
                if (n)
                  n--;
                else if (o[a++] = v, a === e)
                  return o;
              }
              (h || i) && (u[v] = 1), p = !0;
            }
            if (i && (x = (c[v] || 0) + 1, c[v] = x, x < s)) {
              const B = i[x - 2] || (i[x - 2] = []);
              B[B.length] = v;
            }
          } else
            u[v] = 1;
    }
    if (i)
      r || (c = u);
    else if (!p)
      return [];
    r = u;
  }
  if (i)
    for (let h = i.length - 1, f, l; 0 <= h; h--) {
      f = i[h], l = f.length;
      for (let u = 0, p; u < l; u++)
        if (p = f[u], !r[p]) {
          if (n)
            n--;
          else if (o[a++] = p, a === e)
            return o;
          r[p] = 1;
        }
    }
  return o;
}
function xs(t, e) {
  const n = C(), i = C(), s = [];
  for (let o = 0; o < t.length; o++)
    n[t[o]] = 1;
  for (let o = 0, r; o < e.length; o++) {
    r = e[o];
    for (let c = 0, a; c < r.length; c++)
      a = r[c], n[a] && !i[a] && (i[a] = 1, s[s.length] = a);
  }
  return s;
}
function Vt(t) {
  this.l = t !== !0 && t, this.cache = C(), this.h = [];
}
function _n(t, e, n) {
  X(t) && (t = t.query);
  let i = this.cache.get(t);
  return i || (i = this.search(t, e, n), this.cache.set(t, i)), i;
}
Vt.prototype.set = function (t, e) {
  if (!this.cache[t]) {
    var n = this.h.length;
    for (n === this.l ? delete this.cache[this.h[n - 1]] : n++, --n; 0 < n; n--)
      this.h[n] = this.h[n - 1];
    this.h[0] = t;
  }
  this.cache[t] = e;
};
Vt.prototype.get = function (t) {
  const e = this.cache[t];
  if (this.l && e && (t = this.h.indexOf(t))) {
    const n = this.h[t - 1];
    this.h[t - 1] = this.h[t], this.h[t] = n;
  }
  return e;
};
const ys = { memory: { charset: "latin:extra", D: 3, B: 4, m: !1 }, performance: { D: 3, B: 3, s: !1, context: { depth: 2, D: 1 } }, match: { charset: "latin:extra", G: "reverse" }, score: { charset: "latin:advanced", D: 20, B: 3, context: { depth: 3, D: 9 } }, default: {} };
function Pn(t, e, n, i, s, o, r, c) {
  setTimeout(function () {
    const a = t(n ? n + "." + i : i, JSON.stringify(r));
    a && a.then ? a.then(function () {
      e.export(t, e, n, s, o + 1, c);
    }) : e.export(t, e, n, s, o + 1, c);
  });
}
function Q(t, e) {
  if (!(this instanceof Q))
    return new Q(t);
  var n;
  if (t) {
    P(t) ? t = ys[t] : (n = t.preset) && (t = Object.assign({}, n[n], t)), n = t.charset;
    var i = t.lang;
    P(n) && (n.indexOf(":") === -1 && (n += ":default"), n = tt[n]), P(i) && (i = Rn[i]);
  } else
    t = {};
  let s, o, r = t.context || {};
  if (this.encode = t.encode || n && n.encode || An, this.register = e || C(), this.D = s = t.resolution || 9, this.G = e = n && n.G || t.tokenize || "strict", this.depth = e === "strict" && r.depth, this.l = It(r.bidirectional), this.s = o = It(t.optimize), this.m = It(t.fastupdate), this.B = t.minlength || 1, this.C = t.boost, this.map = o ? qe(s) : C(), this.A = s = r.resolution || 1, this.h = o ? qe(s) : C(), this.F = n && n.F || t.rtl, this.H = (e = t.matcher || i && i.H) && Xe(e, !1), this.J = (e = t.stemmer || i && i.J) && Xe(e, !0), n = e = t.filter || i && i.filter) {
    n = e, i = C();
    for (let c = 0, a = n.length; c < a; c++)
      i[n[c]] = 1;
    n = i;
  }
  this.filter = n, this.cache = (e = t.cache) && new Vt(e);
}
R = Q.prototype;
R.append = function (t, e) {
  return this.add(t, e, !0);
};
R.add = function (t, e, n, i) {
  if (e && (t || t === 0)) {
    if (!i && !n && this.register[t])
      return this.update(t, e);
    if (e = this.encode(e), i = e.length) {
      const h = C(), f = C(), l = this.depth, u = this.D;
      for (let p = 0; p < i; p++) {
        let d = e[this.F ? i - 1 - p : p];
        var s = d.length;
        if (d && s >= this.B && (l || !f[d])) {
          var o = At(u, i, p), r = "";
          switch (this.G) {
            case "full":
              if (2 < s) {
                for (o = 0; o < s; o++)
                  for (var c = s; c > o; c--)
                    if (c - o >= this.B) {
                      var a = At(u, i, p, s, o);
                      r = d.substring(o, c), ht(this, f, r, a, t, n);
                    }
                break;
              }
            case "reverse":
              if (1 < s) {
                for (c = s - 1; 0 < c; c--)
                  r = d[c] + r, r.length >= this.B && ht(
                    this,
                    f,
                    r,
                    At(u, i, p, s, c),
                    t,
                    n
                  );
                r = "";
              }
            case "forward":
              if (1 < s) {
                for (c = 0; c < s; c++)
                  r += d[c], r.length >= this.B && ht(this, f, r, o, t, n);
                break;
              }
            default:
              if (this.C && (o = Math.min(o / this.C(e, d, p) | 0, u - 1)), ht(this, f, d, o, t, n), l && 1 < i && p < i - 1) {
                for (s = C(), r = this.A, o = d, c = Math.min(l + 1, i - p), s[o] = 1, a = 1; a < c; a++)
                  if ((d = e[this.F ? i - 1 - p - a : p + a]) && d.length >= this.B && !s[d]) {
                    s[d] = 1;
                    const b = this.l && d > o;
                    ht(this, h, b ? o : d, At(r + (i / 2 > r ? 0 : 1), i, p, c - 1, a - 1), t, n, b ? d : o);
                  }
              }
          }
        }
      }
      this.m || (this.register[t] = 1);
    }
  }
  return this;
};
function At(t, e, n, i, s) {
  return n && 1 < t ? e + (i || 0) <= t ? n + (s || 0) : (t - 1) / (e + (i || 0)) * (n + (s || 0)) + 1 | 0 : 0;
}
function ht(t, e, n, i, s, o, r) {
  let c = r ? t.h : t.map;
  (!e[n] || r && !e[n][r]) && (t.s && (c = c[i]), r ? (e = e[n] || (e[n] = C()), e[r] = 1, c = c[r] || (c[r] = C())) : e[n] = 1, c = c[n] || (c[n] = []), t.s || (c = c[i] || (c[i] = [])), o && c.includes(s) || (c[c.length] = s, t.m && (t = t.register[s] || (t.register[s] = []), t[t.length] = c)));
}
R.search = function (t, e, n) {
  n || (!e && X(t) ? (n = t, t = n.query) : X(e) && (n = e));
  let i = [], s, o, r = 0;
  if (n) {
    t = n.query || t, e = n.limit, r = n.offset || 0;
    var c = n.context;
    o = n.suggest;
  }
  if (t && (t = this.encode("" + t), s = t.length, 1 < s)) {
    n = C();
    var a = [];
    for (let f = 0, l = 0, u; f < s; f++)
      if ((u = t[f]) && u.length >= this.B && !n[u])
        if (this.s || o || this.map[u])
          a[l++] = u, n[u] = 1;
        else
          return i;
    t = a, s = t.length;
  }
  if (!s)
    return i;
  e || (e = 100), c = this.depth && 1 < s && c !== !1, n = 0;
  let h;
  c ? (h = t[0], n = 1) : 1 < s && t.sort(gs);
  for (let f, l; n < s; n++) {
    if (l = t[n], c ? (f = Ge(
      this,
      i,
      o,
      e,
      r,
      s === 2,
      l,
      h
    ), o && f === !1 && i.length || (h = l)) : f = Ge(this, i, o, e, r, s === 1, l), f)
      return f;
    if (o && n === s - 1) {
      if (a = i.length, !a) {
        if (c) {
          c = 0, n = -1;
          continue;
        }
        return i;
      }
      if (a === 1)
        return zn(i[0], e, r);
    }
  }
  return Nn(i, e, r, o);
};
function Ge(t, e, n, i, s, o, r, c) {
  let a = [], h = c ? t.h : t.map;
  if (t.s || (h = Ue(h, r, c, t.l)), h) {
    let f = 0;
    const l = Math.min(h.length, c ? t.A : t.D);
    for (let u = 0, p = 0, d, b; u < l && !((d = h[u]) && (t.s && (d = Ue(d, r, c, t.l)), s && d && o && (b = d.length, b <= s ? (s -= b, d = null) : (d = d.slice(s), s = 0)), d && (a[f++] = d, o && (p += d.length, p >= i)))); u++)
      ;
    if (f) {
      if (o)
        return zn(a, i, 0);
      e[e.length] = a;
      return;
    }
  }
  return !n && a;
}
function zn(t, e, n) {
  return t = t.length === 1 ? t[0] : [].concat.apply([], t), n || t.length > e ? t.slice(n, n + e) : t;
}
function Ue(t, e, n, i) {
  return n ? (i = i && e > n, t = (t = t[i ? e : n]) && t[i ? n : e]) : t = t[e], t;
}
R.contain = function (t) {
  return !!this.register[t];
};
R.update = function (t, e) {
  return this.remove(t).add(t, e);
};
R.remove = function (t, e) {
  const n = this.register[t];
  if (n) {
    if (this.m)
      for (let i = 0, s; i < n.length; i++)
        s = n[i], s.splice(s.indexOf(t), 1);
    else
      Lt(this.map, t, this.D, this.s), this.depth && Lt(this.h, t, this.A, this.s);
    if (e || delete this.register[t], this.cache) {
      e = this.cache;
      for (let i = 0, s, o; i < e.h.length; i++)
        o = e.h[i], s = e.cache[o], s.includes(t) && (e.h.splice(i--, 1), delete e.cache[o]);
    }
  }
  return this;
};
function Lt(t, e, n, i, s) {
  let o = 0;
  if (t.constructor === Array)
    if (s)
      e = t.indexOf(e), e !== -1 ? 1 < t.length && (t.splice(e, 1), o++) : o++;
    else {
      s = Math.min(t.length, n);
      for (let r = 0, c; r < s; r++)
        (c = t[r]) && (o = Lt(c, e, n, i, s), i || o || delete t[r]);
    }
  else
    for (let r in t)
      (o = Lt(t[r], e, n, i, s)) || delete t[r];
  return o;
}
R.searchCache = _n;
R.export = function (t, e, n, i, s, o) {
  let r = !0;
  typeof o > "u" && (r = new Promise((h) => {
    o = h;
  }));
  let c, a;
  switch (s || (s = 0)) {
    case 0:
      if (c = "reg", this.m) {
        a = C();
        for (let h in this.register)
          a[h] = 1;
      } else
        a = this.register;
      break;
    case 1:
      c = "cfg", a = { doc: 0, opt: this.s ? 1 : 0 };
      break;
    case 2:
      c = "map", a = this.map;
      break;
    case 3:
      c = "ctx", a = this.h;
      break;
    default:
      typeof n > "u" && o && o();
      return;
  }
  return Pn(t, e || this, n, c, i, s, a, o), r;
};
R.import = function (t, e) {
  if (e)
    switch (P(e) && (e = JSON.parse(e)), t) {
      case "cfg":
        this.s = !!e.opt;
        break;
      case "reg":
        this.m = !1, this.register = e;
        break;
      case "map":
        this.map = e;
        break;
      case "ctx":
        this.h = e;
    }
};
In(Q.prototype);
function vs(t) {
  t = t.data;
  var e = self._index;
  const n = t.args;
  var i = t.task;
  switch (i) {
    case "init":
      i = t.options || {}, t = t.factory, e = i.encode, i.cache = !1, e && e.indexOf("function") === 0 && (i.encode = Function("return " + e)()), t ? (Function("return " + t)()(self), self._index = new self.FlexSearch.Index(i), delete self.FlexSearch) : self._index = new Q(i);
      break;
    default:
      t = t.id, e = e[i].apply(e, n), postMessage(i === "search" ? { id: t, msg: e } : { id: t });
  }
}
let Ze = 0;
function ot(t) {
  if (!(this instanceof ot))
    return new ot(t);
  var e;
  t ? ve(e = t.encode) && (t.encode = e.toString()) : t = {}, (e = (self || window)._factory) && (e = e.toString());
  const n = typeof window > "u" && self.exports, i = this;
  this.o = ks(e, n, t.worker), this.h = C(), this.o && (n ? this.o.on("message", function (s) {
    i.h[s.id](s.msg), delete i.h[s.id];
  }) : this.o.onmessage = function (s) {
    s = s.data, i.h[s.id](s.msg), delete i.h[s.id];
  }, this.o.postMessage({ task: "init", factory: e, options: t }));
}
mt("add");
mt("append");
mt("search");
mt("update");
mt("remove");
function mt(t) {
  ot.prototype[t] = ot.prototype[t + "Async"] = function () {
    const e = this, n = [].slice.call(arguments);
    var i = n[n.length - 1];
    let s;
    return ve(i) && (s = i, n.splice(n.length - 1, 1)), i = new Promise(function (o) {
      setTimeout(function () {
        e.h[++Ze] = o, e.o.postMessage({ task: t, id: Ze, args: n });
      });
    }), s ? (i.then(s), this) : i;
  };
}
function ks(t, e, n) {
  let i;
  try {
    i = e ? new (require("worker_threads")).Worker(__dirname + "/node/node.js") : t ? new Worker(URL.createObjectURL(new Blob(["onmessage=" + vs.toString()], { type: "text/javascript" }))) : new Worker(P(n) ? n : "worker/worker.js", { type: "module" });
  } catch {
  }
  return i;
}
function gt(t) {
  if (!(this instanceof gt))
    return new gt(t);
  var e = t.document || t.doc || t, n;
  this.K = [], this.h = [], this.A = [], this.register = C(), this.key = (n = e.key || e.id) && Rt(n, this.A) || "id", this.m = It(t.fastupdate), this.C = (n = e.store) && n !== !0 && [], this.store = n && C(), this.I = (n = e.tag) && Rt(n, this.A), this.l = n && C(), this.cache = (n = t.cache) && new Vt(n), t.cache = !1, this.o = t.worker, this.async = !1, n = C();
  let i = e.index || e.field || e;
  P(i) && (i = [i]);
  for (let s = 0, o, r; s < i.length; s++)
    o = i[s], P(o) || (r = o, o = o.field), r = X(r) ? Object.assign({}, t, r) : t, this.o && (n[o] = new ot(r), n[o].o || (this.o = !1)), this.o || (n[o] = new Q(r, this.register)), this.K[s] = Rt(o, this.A), this.h[s] = o;
  if (this.C)
    for (t = e.store, P(t) && (t = [t]), e = 0; e < t.length; e++)
      this.C[e] = Rt(t[e], this.A);
  this.index = n;
}
function Rt(t, e) {
  const n = t.split(":");
  let i = 0;
  for (let s = 0; s < n.length; s++)
    t = n[s], 0 <= t.indexOf("[]") && (t = t.substring(0, t.length - 2)) && (e[i] = !0), t && (n[i++] = t);
  return i < n.length && (n.length = i), 1 < i ? n : n[0];
}
function re(t, e) {
  if (P(e))
    t = t[e];
  else
    for (let n = 0; t && n < e.length; n++)
      t = t[e[n]];
  return t;
}
function ce(t, e, n, i, s) {
  if (t = t[s], i === n.length - 1)
    e[s] = t;
  else if (t)
    if (t.constructor === Array)
      for (e = e[s] = Array(t.length), s = 0; s < t.length; s++)
        ce(t, e, n, i, s);
    else
      e = e[s] || (e[s] = C()), s = n[++i], ce(t, e, n, i, s);
}
function ae(t, e, n, i, s, o, r, c) {
  if (t = t[r])
    if (i === e.length - 1) {
      if (t.constructor === Array) {
        if (n[i]) {
          for (e = 0; e < t.length; e++)
            s.add(o, t[e], !0, !0);
          return;
        }
        t = t.join(" ");
      }
      s.add(o, t, c, !0);
    } else if (t.constructor === Array)
      for (r = 0; r < t.length; r++)
        ae(t, e, n, i, s, o, r, c);
    else
      r = e[++i], ae(t, e, n, i, s, o, r, c);
}
R = gt.prototype;
R.add = function (t, e, n) {
  if (X(t) && (e = t, t = re(e, this.key)), e && (t || t === 0)) {
    if (!n && this.register[t])
      return this.update(t, e);
    for (let i = 0, s, o; i < this.h.length; i++)
      o = this.h[i], s = this.K[i], P(s) && (s = [s]), ae(e, s, this.A, 0, this.index[o], t, s[0], n);
    if (this.I) {
      let i = re(e, this.I), s = C();
      P(i) && (i = [i]);
      for (let o = 0, r, c; o < i.length; o++)
        if (r = i[o], !s[r] && (s[r] = 1, c = this.l[r] || (this.l[r] = []), !n || !c.includes(t)) && (c[c.length] = t, this.m)) {
          const a = this.register[t] || (this.register[t] = []);
          a[a.length] = c;
        }
    }
    if (this.store && (!n || !this.store[t])) {
      let i;
      if (this.C) {
        i = C();
        for (let s = 0, o; s < this.C.length; s++)
          o = this.C[s], P(o) ? i[o] = e[o] : ce(e, i, o, 0, o[0]);
      }
      this.store[t] = i || e;
    }
  }
  return this;
};
R.append = function (t, e) {
  return this.add(t, e, !0);
};
R.update = function (t, e) {
  return this.remove(t).add(t, e);
};
R.remove = function (t) {
  if (X(t) && (t = re(t, this.key)), this.register[t]) {
    for (var e = 0; e < this.h.length && (this.index[this.h[e]].remove(t, !this.o), !this.m); e++)
      ;
    if (this.I && !this.m)
      for (let n in this.l) {
        e = this.l[n];
        const i = e.indexOf(t);
        i !== -1 && (1 < e.length ? e.splice(i, 1) : delete this.l[n]);
      }
    this.store && delete this.store[t], delete this.register[t];
  }
  return this;
};
R.search = function (t, e, n, i) {
  n || (!e && X(t) ? (n = t, t = "") : X(e) && (n = e, e = 0));
  let s = [], o = [], r, c, a, h, f, l, u = 0;
  if (n)
    if (n.constructor === Array)
      a = n, n = null;
    else {
      if (t = n.query || t, a = (r = n.pluck) || n.index || n.field, h = n.tag, c = this.store && n.enrich, f = n.bool === "and", e = n.limit || e || 100, l = n.offset || 0, h && (P(h) && (h = [h]), !t)) {
        for (let d = 0, b; d < h.length; d++)
          (b = Ms.call(this, h[d], e, l, c)) && (s[s.length] = b, u++);
        return u ? s : [];
      }
      P(a) && (a = [a]);
    }
  a || (a = this.h), f = f && (1 < a.length || h && 1 < h.length);
  const p = !i && (this.o || this.async) && [];
  for (let d = 0, b, k, S; d < a.length; d++) {
    let x;
    if (k = a[d], P(k) || (x = k, k = x.field, t = x.query || t, e = x.limit || e, c = x.enrich || c), p)
      p[d] = this.index[k].searchAsync(t, e, x || n);
    else {
      if (i ? b = i[d] : b = this.index[k].search(t, e, x || n), S = b && b.length, h && S) {
        const v = [];
        let B = 0;
        f && (v[0] = [b]);
        for (let A = 0, T, F; A < h.length; A++)
          T = h[A], (S = (F = this.l[T]) && F.length) && (B++, v[v.length] = f ? [F] : F);
        B && (b = f ? Nn(v, e || 100, l || 0) : xs(b, v), S = b.length);
      }
      if (S)
        o[u] = k, s[u++] = b;
      else if (f)
        return [];
    }
  }
  if (p) {
    const d = this;
    return new Promise(function (b) {
      Promise.all(p).then(function (k) {
        b(d.search(
          t,
          e,
          n,
          k
        ));
      });
    });
  }
  if (!u)
    return [];
  if (r && (!c || !this.store))
    return s[0];
  for (let d = 0, b; d < o.length; d++) {
    if (b = s[d], b.length && c && (b = $n.call(this, b)), r)
      return b;
    s[d] = { field: o[d], result: b };
  }
  return s;
};
function Ms(t, e, n, i) {
  let s = this.l[t], o = s && s.length - n;
  if (o && 0 < o)
    return (o > e || n) && (s = s.slice(n, n + e)), i && (s = $n.call(this, s)), { tag: t, result: s };
}
function $n(t) {
  const e = Array(t.length);
  for (let n = 0, i; n < t.length; n++)
    i = t[n], e[n] = { id: i, doc: this.store[i] };
  return e;
}
R.contain = function (t) {
  return !!this.register[t];
};
R.get = function (t) {
  return this.store[t];
};
R.set = function (t, e) {
  return this.store[t] = e, this;
};
R.searchCache = _n;
R.export = function (t, e, n, i, s, o) {
  let r;
  if (typeof o > "u" && (r = new Promise((c) => {
    o = c;
  })), s || (s = 0), i || (i = 0), i < this.h.length) {
    const c = this.h[i], a = this.index[c];
    e = this, setTimeout(function () {
      a.export(t, e, s ? c : "", i, s++, o) || (i++, s = 1, e.export(t, e, c, i, s, o));
    });
  } else {
    let c, a;
    switch (s) {
      case 1:
        c = "tag", a = this.l, n = null;
        break;
      case 2:
        c = "store", a = this.store, n = null;
        break;
      default:
        o();
        return;
    }
    Pn(t, this, n, c, i, s, a, o);
  }
  return r;
};
R.import = function (t, e) {
  if (e)
    switch (P(e) && (e = JSON.parse(e)), t) {
      case "tag":
        this.l = e;
        break;
      case "reg":
        this.m = !1, this.register = e;
        for (let i = 0, s; i < this.h.length; i++)
          s = this.index[this.h[i]], s.register = e, s.m = !1;
        break;
      case "store":
        this.store = e;
        break;
      default:
        t = t.split(".");
        const n = t[0];
        t = t[1], n && t && this.index[n].import(t, e);
    }
};
In(gt.prototype);
var Cs = { encode: En, F: !1, G: "" };
const Ss = [I("[àáâãäå]"), "a", I("[èéêë]"), "e", I("[ìíîï]"), "i", I("[òóôõöő]"), "o", I("[ùúûüű]"), "u", I("[ýŷÿ]"), "y", I("ñ"), "n", I("[çc]"), "k", I("ß"), "s", I(" & "), " and "];
function En(t) {
  var e = t = "" + t;
  return e.normalize && (e = e.normalize("NFD").replace(ms, "")), Cn.call(this, e.toLowerCase(), !t.normalize && Ss);
}
var As = { encode: Bn, F: !1, G: "strict" };
const Rs = /[^a-z0-9]+/, Je = { b: "p", v: "f", w: "f", z: "s", x: "s", ß: "s", d: "t", n: "m", c: "k", g: "k", j: "k", q: "k", i: "e", y: "e", u: "o" };
function Bn(t) {
  t = En.call(this, t).join(" ");
  const e = [];
  if (t) {
    const n = t.split(Rs), i = n.length;
    for (let s = 0, o, r = 0; s < i; s++)
      if ((t = n[s]) && (!this.filter || !this.filter[t])) {
        o = t[0];
        let c = Je[o] || o, a = c;
        for (let h = 1; h < t.length; h++) {
          o = t[h];
          const f = Je[o] || o;
          f && f !== a && (c += f, a = f);
        }
        e[r++] = c;
      }
  }
  return e;
}
var Is = { encode: Fn, F: !1, G: "" };
const Ns = [I("ae"), "a", I("oe"), "o", I("sh"), "s", I("th"), "t", I("ph"), "f", I("pf"), "f", I("(?![aeo])h(?![aeo])"), "", I("(?!^[aeo])h(?!^[aeo])"), ""];
function Fn(t, e) {
  return t && (t = Bn.call(this, t).join(" "), 2 < t.length && (t = Nt(t, Ns)), e || (1 < t.length && (t = Sn(t)), t && (t = t.split(" ")))), t || [];
}
var _s = { encode: zs, F: !1, G: "" };
const Ps = I("(?!\\b)[aeo]");
function zs(t) {
  return t && (t = Fn.call(this, t, !0), 1 < t.length && (t = t.replace(Ps, "")), 1 < t.length && (t = Sn(t)), t && (t = t.split(" "))), t || [];
}
tt["latin:default"] = ws;
tt["latin:simple"] = Cs;
tt["latin:balance"] = As;
tt["latin:advanced"] = Is;
tt["latin:extra"] = _s;
const $s = {
  Index: Q, Document: gt, Worker: ot, registerCharset: function (t, e) {
    tt[t] = e;
  }, registerLanguage: function (t, e) {
    Rn[t] = e;
  }
};
function Es(t) {
  const e = new $s.Index({
    tokenize: "full"
  });
  for (let n = 0; n < t.length; n++)
    e.add(n, t[n].text.trim());
  return (n) => {
    const i = e.search(n), s = new Array(i.length);
    for (let o = 0; o < i.length; o++)
      s[o] = t[i[o]];
    return s;
  };
}
class Bs {
  constructor(e, n, i, s) {
    this.onSearch = i, this.onMatch = s, this.#t = e, this.#i = Es(Fs(e.scan));
    const o = document.createElement("input");
    o.type = "search", o.placeholder = "Search", o.title = "Search", z(o, {
      fontSize: "12px",
      padding: "0 4px",
      flexGrow: "1",
      width: "100%",
      height: g(n)
    }), o.addEventListener(
      "input",
      Ki(1e3, () => this.#a(o.value))
    );
    const r = Ot(250, (u) => {
      switch (u.key) {
        case "ArrowUp":
          u.preventDefault(), this.jumpPrev();
          break;
        case "ArrowDown":
          u.preventDefault(), this.jumpNext();
          break;
        case "Enter":
          u.preventDefault(), u.shiftKey ? this.jumpPrev() : this.jumpNext();
          break;
        case "Escape":
          this.toggle();
          break;
      }
    });
    o.addEventListener("keydown", r), this.#n = o;
    const c = m({
      fontSize: "12px",
      color: "#666"
    });
    this.#e = c;
    const a = m(
      {
        width: "280px",
        // TODO: dynamic width
        display: "flex",
        alignItems: "center",
        marginRight: M(1)
      },
      o,
      c
    ), h = _(wn, 20, "Previous match", () => this.jumpPrev()), f = _(we, 20, "Next match", () => this.jumpNext()), l = _(xn, 20, "Close", () => this.toggle());
    this.root = m(
      {
        display: "none",
        alignItems: "center",
        padding: `0 ${M(1)}}`
      },
      a,
      h,
      f,
      l
    );
  }
  root;
  #t;
  #e;
  #n;
  #i;
  #o = !1;
  #a(e) {
    const n = e.length ? this.#i(e).sort((o, r) => o.nodes[0].id - r.nodes[0].id) : [], i = n.length ? 0 : -1, s = this.#t.search;
    this.#t.search = { term: e, matches: n, index: i }, this.onSearch(s, this.#t.search), this.jumpToMatch(0);
  }
  jumpToMatch(e) {
    const n = this.#t.search, i = n.matches.length, s = {
      term: n.term,
      matches: n.matches,
      index: i > 0 ? e < 0 ? i - 1 : e % i : -1
    };
    this.#t.search = s, this.#e.textContent = i > 0 ? `${s.index + 1}/${i}` : "", i && this.onMatch(n, s);
  }
  jumpPrev() {
    this.jumpToMatch(this.#t.search.index - 1);
  }
  jumpNext() {
    this.jumpToMatch(this.#t.search.index + 1);
  }
  toggle() {
    this.#o = !this.#o, this.#o ? (this.root.style.display = "flex", this.#n.focus()) : (this.root.style.display = "none", this.#n.value = "", this.#a(""));
  }
}
function Fs(t) {
  const e = [];
  for (const n of t.sections)
    for (const i of n.parts)
      e.push(i);
  return e;
}
class js {
  constructor(e, n, i, s) {
    this.choices = n;
    const o = document.createElement("select");
    z(o, {
      fontSize: g(12),
      height: g(e),
      background: "inherit"
    });
    for (let r = 0; r < n.length; r++) {
      const c = n[r], a = document.createElement("option");
      a.textContent = c.label, a.value = "" + r, o.appendChild(a);
    }
    o.value = "" + n.indexOf(i), o.addEventListener("change", () => s(n[parseInt(o.value)].value)), this.root = o;
  }
  root;
  select(e) {
    const n = this.root;
    n.value = "" + this.choices.indexOf(e);
  }
}
class Ls {
  constructor() {
    this.ids = [], this.values = [], this.length = 0;
  }
  clear() {
    this.length = 0;
  }
  push(e, n) {
    let i = this.length++;
    for (; i > 0;) {
      const s = i - 1 >> 1, o = this.values[s];
      if (n >= o)
        break;
      this.ids[i] = this.ids[s], this.values[i] = o, i = s;
    }
    this.ids[i] = e, this.values[i] = n;
  }
  pop() {
    if (this.length === 0)
      return;
    const e = this.ids[0];
    if (this.length--, this.length > 0) {
      const n = this.ids[0] = this.ids[this.length], i = this.values[0] = this.values[this.length], s = this.length >> 1;
      let o = 0;
      for (; o < s;) {
        let r = (o << 1) + 1;
        const c = r + 1;
        let a = this.ids[r], h = this.values[r];
        const f = this.values[c];
        if (c < this.length && f < h && (r = c, a = this.ids[c], h = f), h >= i)
          break;
        this.ids[o] = a, this.values[o] = h, o = r;
      }
      this.ids[o] = n, this.values[o] = i;
    }
    return e;
  }
  peek() {
    if (this.length !== 0)
      return this.ids[0];
  }
  peekValue() {
    if (this.length !== 0)
      return this.values[0];
  }
  shrink() {
    this.ids.length = this.values.length = this.length;
  }
}
const Ke = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], Jt = 3;
class ke {
  /**
   * Recreate a Flatbush index from raw `ArrayBuffer` or `SharedArrayBuffer` data.
   * @param {ArrayBuffer | SharedArrayBuffer} data
   * @param {number} [byteOffset=0] byte offset to the start of the Flatbush buffer in the referenced ArrayBuffer.
   * @returns {Flatbush} index
   */
  static from(e, n = 0) {
    if (n % 8 !== 0)
      throw new Error("byteOffset must be 8-byte aligned.");
    if (!e || e.byteLength === void 0 || e.buffer)
      throw new Error("Data must be an instance of ArrayBuffer or SharedArrayBuffer.");
    const [i, s] = new Uint8Array(e, n + 0, 2);
    if (i !== 251)
      throw new Error("Data does not appear to be in a Flatbush format.");
    const o = s >> 4;
    if (o !== Jt)
      throw new Error(`Got v${o} data when expected v${Jt}.`);
    const r = Ke[s & 15];
    if (!r)
      throw new Error("Unrecognized array type.");
    const [c] = new Uint16Array(e, n + 2, 1), [a] = new Uint32Array(e, n + 4, 1);
    return new ke(a, c, r, void 0, e, n);
  }
  /**
   * Create a Flatbush index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=16] Size of the tree node (16 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBufferConstructor | SharedArrayBufferConstructor} [ArrayBufferType=ArrayBuffer] The array buffer type used to store data (`ArrayBuffer` by default).
   * @param {ArrayBuffer | SharedArrayBuffer} [data] (Only used internally)
   * @param {number} [byteOffset=0] (Only used internally)
   */
  constructor(e, n = 16, i = Float64Array, s = ArrayBuffer, o, r = 0) {
    if (e === void 0)
      throw new Error("Missing required argument: numItems.");
    if (isNaN(e) || e <= 0)
      throw new Error(`Unexpected numItems value: ${e}.`);
    this.numItems = +e, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.byteOffset = r;
    let c = e, a = c;
    this._levelBounds = [c * 4];
    do
      c = Math.ceil(c / this.nodeSize), a += c, this._levelBounds.push(a * 4);
    while (c !== 1);
    this.ArrayType = i, this.IndexArrayType = a < 16384 ? Uint16Array : Uint32Array;
    const h = Ke.indexOf(this.ArrayType), f = a * 4 * this.ArrayType.BYTES_PER_ELEMENT;
    if (h < 0)
      throw new Error(`Unexpected typed array class: ${i}.`);
    o && o.byteLength !== void 0 && !o.buffer ? (this.data = o, this._boxes = new this.ArrayType(this.data, r + 8, a * 4), this._indices = new this.IndexArrayType(this.data, r + 8 + f, a), this._pos = a * 4, this.minX = this._boxes[this._pos - 4], this.minY = this._boxes[this._pos - 3], this.maxX = this._boxes[this._pos - 2], this.maxY = this._boxes[this._pos - 1]) : (this.data = new s(8 + f + a * this.IndexArrayType.BYTES_PER_ELEMENT), this._boxes = new this.ArrayType(this.data, 8, a * 4), this._indices = new this.IndexArrayType(this.data, 8 + f, a), this._pos = 0, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, new Uint8Array(this.data, 0, 2).set([251, (Jt << 4) + h]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = e), this._queue = new Ls();
  }
  /**
   * Add a given rectangle to the index.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number} A zero-based, incremental number that represents the newly added rectangle.
   */
  add(e, n, i = e, s = n) {
    const o = this._pos >> 2, r = this._boxes;
    return this._indices[o] = o, r[this._pos++] = e, r[this._pos++] = n, r[this._pos++] = i, r[this._pos++] = s, e < this.minX && (this.minX = e), n < this.minY && (this.minY = n), i > this.maxX && (this.maxX = i), s > this.maxY && (this.maxY = s), o;
  }
  /** Perform indexing of the added rectangles. */
  finish() {
    if (this._pos >> 2 !== this.numItems)
      throw new Error(`Added ${this._pos >> 2} items when expected ${this.numItems}.`);
    const e = this._boxes;
    if (this.numItems <= this.nodeSize) {
      e[this._pos++] = this.minX, e[this._pos++] = this.minY, e[this._pos++] = this.maxX, e[this._pos++] = this.maxY;
      return;
    }
    const n = this.maxX - this.minX || 1, i = this.maxY - this.minY || 1, s = new Uint32Array(this.numItems), o = 65535;
    for (let r = 0, c = 0; r < this.numItems; r++) {
      const a = e[c++], h = e[c++], f = e[c++], l = e[c++], u = Math.floor(o * ((a + f) / 2 - this.minX) / n), p = Math.floor(o * ((h + l) / 2 - this.minY) / i);
      s[r] = Hs(u, p);
    }
    he(s, e, this._indices, 0, this.numItems - 1, this.nodeSize);
    for (let r = 0, c = 0; r < this._levelBounds.length - 1; r++) {
      const a = this._levelBounds[r];
      for (; c < a;) {
        const h = c;
        let f = e[c++], l = e[c++], u = e[c++], p = e[c++];
        for (let d = 1; d < this.nodeSize && c < a; d++)
          f = Math.min(f, e[c++]), l = Math.min(l, e[c++]), u = Math.max(u, e[c++]), p = Math.max(p, e[c++]);
        this._indices[this._pos >> 2] = h, e[this._pos++] = f, e[this._pos++] = l, e[this._pos++] = u, e[this._pos++] = p;
      }
    }
  }
  /**
   * Search the index by a bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @param {(index: number) => boolean} [filterFn] An optional function for filtering the results.
   * @returns {number[]} An array of indices of items intersecting or touching the given bounding box.
   */
  search(e, n, i, s, o) {
    if (this._pos !== this._boxes.length)
      throw new Error("Data not yet indexed - call index.finish().");
    let r = this._boxes.length - 4;
    const c = [], a = [];
    for (; r !== void 0;) {
      const h = Math.min(r + this.nodeSize * 4, tn(r, this._levelBounds));
      for (let f = r; f < h; f += 4) {
        if (i < this._boxes[f] || s < this._boxes[f + 1] || e > this._boxes[f + 2] || n > this._boxes[f + 3])
          continue;
        const l = this._indices[f >> 2] | 0;
        r >= this.numItems * 4 ? c.push(l) : (o === void 0 || o(l)) && a.push(l);
      }
      r = c.pop();
    }
    return a;
  }
  /**
   * Search items in order of distance from the given point.
   * @param {number} x
   * @param {number} y
   * @param {number} [maxResults=Infinity]
   * @param {number} [maxDistance=Infinity]
   * @param {(index: number) => boolean} [filterFn] An optional function for filtering the results.
   * @returns {number[]} An array of indices of items found.
   */
  neighbors(e, n, i = 1 / 0, s = 1 / 0, o) {
    if (this._pos !== this._boxes.length)
      throw new Error("Data not yet indexed - call index.finish().");
    let r = this._boxes.length - 4;
    const c = this._queue, a = [], h = s * s;
    t:
    for (; r !== void 0;) {
      const f = Math.min(r + this.nodeSize * 4, tn(r, this._levelBounds));
      for (let l = r; l < f; l += 4) {
        const u = this._indices[l >> 2] | 0, p = Qe(e, this._boxes[l], this._boxes[l + 2]), d = Qe(n, this._boxes[l + 1], this._boxes[l + 3]), b = p * p + d * d;
        b > h || (r >= this.numItems * 4 ? c.push(u << 1, b) : (o === void 0 || o(u)) && c.push((u << 1) + 1, b));
      }
      for (; c.length && c.peek() & 1;)
        if (c.peekValue() > h || (a.push(c.pop() >> 1), a.length === i))
          break t;
      r = c.length ? c.pop() >> 1 : void 0;
    }
    return c.clear(), a;
  }
}
function Qe(t, e, n) {
  return t < e ? e - t : t <= n ? 0 : t - n;
}
function tn(t, e) {
  let n = 0, i = e.length - 1;
  for (; n < i;) {
    const s = n + i >> 1;
    e[s] > t ? i = s : n = s + 1;
  }
  return e[n];
}
function he(t, e, n, i, s, o) {
  if (Math.floor(i / o) >= Math.floor(s / o))
    return;
  const r = t[i + s >> 1];
  let c = i - 1, a = s + 1;
  for (; ;) {
    do
      c++;
    while (t[c] < r);
    do
      a--;
    while (t[a] > r);
    if (c >= a)
      break;
    Ts(t, e, n, c, a);
  }
  he(t, e, n, i, a, o), he(t, e, n, a + 1, s, o);
}
function Ts(t, e, n, i, s) {
  const o = t[i];
  t[i] = t[s], t[s] = o;
  const r = 4 * i, c = 4 * s, a = e[r], h = e[r + 1], f = e[r + 2], l = e[r + 3];
  e[r] = e[c], e[r + 1] = e[c + 1], e[r + 2] = e[c + 2], e[r + 3] = e[c + 3], e[c] = a, e[c + 1] = h, e[c + 2] = f, e[c + 3] = l;
  const u = n[i];
  n[i] = n[s], n[s] = u;
}
function Hs(t, e) {
  let n = t ^ e, i = 65535 ^ n, s = 65535 ^ (t | e), o = t & (e ^ 65535), r = n | i >> 1, c = n >> 1 ^ n, a = s >> 1 ^ i & o >> 1 ^ s, h = n & s >> 1 ^ o >> 1 ^ o;
  n = r, i = c, s = a, o = h, r = n & n >> 2 ^ i & i >> 2, c = n & i >> 2 ^ i & (n ^ i) >> 2, a ^= n & s >> 2 ^ i & o >> 2, h ^= i & s >> 2 ^ (n ^ i) & o >> 2, n = r, i = c, s = a, o = h, r = n & n >> 4 ^ i & i >> 4, c = n & i >> 4 ^ i & (n ^ i) >> 4, a ^= n & s >> 4 ^ i & o >> 4, h ^= i & s >> 4 ^ (n ^ i) & o >> 4, n = r, i = c, s = a, o = h, a ^= n & s >> 8 ^ i & o >> 8, h ^= i & s >> 8 ^ (n ^ i) & o >> 8, n = a ^ a >> 1, i = h ^ h >> 1;
  let f = t ^ e, l = i | 65535 ^ (f | n);
  return f = (f | f << 8) & 16711935, f = (f | f << 4) & 252645135, f = (f | f << 2) & 858993459, f = (f | f << 1) & 1431655765, l = (l | l << 8) & 16711935, l = (l | l << 4) & 252645135, l = (l | l << 2) & 858993459, l = (l | l << 1) & 1431655765, (l << 1 | f) >>> 0;
}
class Ds {
  #t;
  #e;
  constructor(e) {
    this.#t = new ke(e), this.#e = new Array(e);
  }
  add(e, n, i, s, o) {
    this.#e[this.#t.add(n, i, s, o)] = e;
  }
  finish() {
    this.#t.finish();
  }
  search(e, n, i, s) {
    return this.collect(this.#t.search(e, n, i, s));
  }
  neighbors(e, n, i) {
    return this.collect(this.#t.neighbors(e, n, i));
  }
  collect(e) {
    const n = new Array(e.length);
    if (n.length) {
      const i = this.#e;
      for (let s = 0; s < e.length; s++)
        n[s] = i[e[s]];
    }
    return n;
  }
}
const Os = (t) => qt(t)?.page;
function qt(t) {
  for (const e of jn(t))
    return e;
  return null;
}
function* jn(t) {
  for (const e of t)
    e.t === "t" && (yield e);
}
function Ws(t, e) {
  let n = null, i = -1 / 0;
  for (const s of t) {
    const o = e(s);
    o > i && (n = s, i = o);
  }
  return n;
}
var fe = /* @__PURE__ */ ((t) => (t[t.None = 0] = "None", t[t.Auto = 1] = "Auto", t[t.FitWidth = 2] = "FitWidth", t[t.FitPage = 3] = "FitPage", t[t.Amount = 4] = "Amount", t))(fe || {});
const rt = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 2, 3, 4].map(
  (t) => ({ t: 4, amount: t })
), Ys = {
  t: 0
  /* None */
}, lt = {
  t: 1
  /* Auto */
}, Vs = {
  t: 2
  /* FitWidth */
}, qs = {
  t: 3
  /* FitPage */
}, Ln = rt[3];
function Xs(t, e) {
  if (t.t === 4)
    return t;
  for (let n = rt.length - 1; n >= 0; n--) {
    const i = rt[n];
    if (e > i.amount)
      return i;
  }
  return Ln;
}
function en(t, e, n) {
  const i = rt.indexOf(Xs(t, e)), s = Math.min(rt.length - 1, Math.max(0, i + n));
  return Tn[s];
}
const Gs = (t) => Us.get(t) || Tt[0], Tn = rt.map((t) => ({
  label: `${(t.amount * 100).toFixed(0)}%`,
  value: t
})), Tt = [
  { label: "Auto Zoom", value: lt },
  { label: "Fit Width", value: Vs },
  { label: "Fit Page", value: qs },
  { label: "Actual Size", value: Ln },
  ...Tn
], Us = new Map(Tt.map((t) => [t.value, t])), Kt = 16;
class nn {
  constructor(e) {
    this.root = e;
  }
  timer = 0;
  show() {
    window.clearTimeout(this.timer), Wt(this.root), vn(2e3, () => Yt(this.root));
  }
}
class Zs {
  constructor(e, n, i, s, o, r, c, a, h) {
    switch (this.page = r, this.diff = c, this.onSelect = a, this.onHover = h, this.#t = e, s.t) {
      case fe.FitPage:
        this.scale = Math.min(n / r.width, i / r.height);
        break;
      case fe.Amount:
        this.scale = s.amount;
        break;
      default:
        this.scale = n / r.width;
    }
    this.width = Math.floor(r.width * this.scale), this.height = Math.floor(r.height * this.scale), this.#e = o, this.root = m({
      position: "relative",
      width: g(this.width),
      height: g(this.height),
      backgroundColor: "#fff",
      boxShadow: "0 0 #0000, 0 0 #0000, 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)",
      boxSizing: "border-box"
    });
  }
  root;
  width;
  height;
  #t;
  scale;
  #e;
  #n;
  #i = !0;
  #o = !0;
  visibility = null;
  #a;
  #r = null;
  #c = /* @__PURE__ */ new Set();
  #u = null;
  get graphics() {
    if (this.#n)
      return this.#n;
    const e = xe(this.width, this.height, {
      cursor: "pointer",
      opacity: `${this.#t.opts.highlightOverlayOpacity}`
    });
    e.g.scale(this.scale, this.scale);
    let n = !1, i = !1;
    const { canvas: s } = e;
    s.addEventListener("mouseenter", async () => {
      n = !0, await this.#h(null, i);
    }), s.addEventListener("mouseleave", async () => {
      n = !1, await this.#h(null, i);
    }), s.addEventListener("mousedown", (a) => {
      a.preventDefault(), i = !0, a.shiftKey || this.onSelect([], !1), this.#r && this.#c.add(this.#r);
    }), s.addEventListener("mouseup", (a) => {
      a.preventDefault(), i = !1;
      const h = [...this.#c].sort((f, l) => f.id - l.id);
      this.#c.clear(), this.onSelect(h, a.shiftKey), s.style.cursor = this.#r ? "pointer" : "default";
    }), s.addEventListener("mousemove", async (a) => {
      if (n) {
        const h = a.offsetX, f = a.offsetY, l = this.hitMap.search(h, f, h, f);
        await this.#h(l.length ? l[0] : null, i), s.style.cursor = i ? "cell" : this.#r ? "pointer" : "default";
      }
    });
    const o = q(this.width, this.height), r = new nn(
      m({
        display: "none",
        position: "absolute",
        width: g(Kt),
        height: g(Kt),
        backgroundColor: Dn(w.rose.c500, 0.5),
        borderRadius: g(Kt / 2),
        transform: "translate(-50%, -50%)",
        animation: "h2o-pdf-blink 0.6s infinite"
      })
    ), c = new nn(
      m({
        display: "none",
        position: "absolute",
        width: g(1),
        height: g(1)
      })
    );
    return Bt(this.root, [o.canvas, e.canvas, c.root, r.root]), this.#n = { base: o, overlay: e, blink: r, scroll: c };
  }
  async #h(e, n) {
    let i = !1;
    this.#r !== e && (this.#r = e, this.onHover(e), i = !0), n && e && (this.#c.has(e) || (this.#c.add(e), i = !0)), i && await this.invalidate();
  }
  async copy(e) {
    await this.draw(!0);
    const { pageLensScale: n } = this.#t.opts, i = this.width / this.height;
    let s = Math.floor(e.width * n), o = Math.floor(s / i);
    o > e.height && (o = Math.floor(e.height * n), s = Math.floor(i * o)), (this.width < s || this.height < o) && (s = this.width, o = this.height);
    const r = Math.floor((e.width - s) / 2), c = Math.floor((e.height - o) / 2), { base: a, overlay: h } = this.graphics, f = e.base.g;
    f.clearRect(0, 0, e.width, e.height), f.fillRect(r, c, s, o), f.drawImage(a.canvas, r, c, s, o);
    const l = e.overlay.g;
    l.clearRect(0, 0, e.width, e.height), l.drawImage(h.canvas, r, c, s, o);
  }
  async draw(e = !1) {
    if (!(!e && !this.visibility)) {
      if (this.#i) {
        this.#i = !1;
        const { base: n } = this.graphics;
        console.log("page draw", this.page.id, this.width, this.height);
        const i = q(this.width, this.height);
        await this.#e.draw(this.page.id + 1, i.g, this.scale / i.dpr), n.g.drawImage(i.canvas, 0, 0);
      }
      if (this.#o) {
        this.#o = !1;
        const { overlay: n } = this.graphics;
        this.#m(), this.diff && this.#s(this.diff);
        const i = this.#t.hoveredChars.get(this.page);
        i && (n.g.fillStyle = this.#t.index === 0 ? w.rose.c600 : w.indigo.c600, this.#f(n.g, i));
        const s = this.#t.selectedChars.get(this.page);
        s && (n.g.fillStyle = this.#t.index === 0 ? w.rose.c600 : w.indigo.c600, this.#f(n.g, s));
        const o = this.#t.selectedRelations.get(this.page);
        o && this.#p(o);
        const r = this.#t.hoveredRelations.get(this.page);
        if (r && this.#p(r), this.#r && this.#d(this.#r, w.zinc.c500), this.#c.size)
          for (const l of this.#c)
            this.#d(l, w.zinc.c500);
        const c = this.#t.selections.get(this.page);
        if (c)
          for (const l of c)
            this.#d(l, w.cyan.c500);
        const { term: a, matches: h, index: f } = this.#t.search;
        if (h.length) {
          this.#d(h[f], w.zinc.c500);
          for (let l = 0; l < h.length; l++) {
            const u = h[l], p = Os(u.nodes);
            if (this.page === p) {
              const d = Js(p, a, u.nodes);
              for (const b of d)
                b && (n.g.fillStyle = l === f ? w.rose.c600 : w.rose.c500, this.#f(n.g, b));
            }
          }
        }
      }
    }
  }
  #s(e) {
    let n = this.#u;
    if (!n) {
      const i = this.page, o = (this.#t.index ? e.inserts : e.deletes).filter(({ chars: a }) => {
        for (const h of a)
          if (h.node.page === i)
            return !0;
        return !1;
      }), r = o.filter(({ t: a }) => a === N.Insert), c = o.filter(({ t: a }) => a === N.Delete);
      this.#u = n = { inserted: r, deleted: c };
    }
    this.#l(n);
  }
  #l(e) {
    const n = this.graphics.overlay.g;
    n.fillStyle = w.rose.c500, this.#g(n, e.deleted), n.fillStyle = w.indigo.c500, this.#g(n, e.inserted);
  }
  #g(e, n) {
    for (const { chars: i } of n)
      this.#f(e, i);
  }
  #p(e) {
    for (const { targets: n, colors: i } of e)
      for (let s = 0; s < n.length; s++)
        this.#d(n[s], i[s]);
  }
  #f(e, n) {
    for (const o of n) {
      const [r, c, a, h] = o.box;
      e.fillRect(r - 2, c - 1, a - r + 2 * 2, h - c + 2 * 1);
    }
  }
  #d(e, n) {
    const i = this.graphics.overlay.g;
    i.fillStyle = n, this.#b(i, e.nodes, 2, 1);
  }
  get hitMap() {
    if (this.#a)
      return this.#a;
    const e = this.page.parts;
    let n = 0;
    for (const { nodes: c } of e)
      for (const a of c)
        a.page === this.page && a.t === "t" && n++;
    const i = 2, s = 2, o = new Ds(n), r = this.scale;
    for (const c of e)
      for (const a of c.nodes)
        if (a.page === this.page && a.t === "t") {
          const [h, f, l, u] = a.box;
          o.add(
            c,
            r * h - i,
            r * f - s,
            r * l + 2 * i,
            r * u + 2 * s
          );
        }
    return o.finish(), this.#a = o;
  }
  #b(e, n, i, s) {
    for (const o of n)
      if (o.page === this.page && o.t === "t") {
        const [r, c, a, h] = o.box;
        e.fillRect(r - i, c - s, a - r + 2 * i, h - c + 2 * s);
      }
  }
  async invalidate() {
    this.#o = !0, await this.draw();
  }
  jumpTo() {
    this.root.scrollIntoView();
  }
  jumpToOffset(e, n) {
    const { scroll: i } = this.graphics;
    z(i.root, {
      left: g(e),
      top: g(n)
    }), i.show(), i.root.scrollIntoView();
  }
  jumpToNode(e, n) {
    const i = Ks(e);
    if (!i)
      return;
    const s = this.scale, [o, r, c, a] = i, h = (o + c) / 2 * s, f = (r + a) / 2 * s, { blink: l } = this.graphics;
    z(l.root, { left: g(h), top: g(f) }), l.show();
    const u = o * s, p = r * s;
    this.jumpToOffset(u, p - n);
  }
  calculateNodeOffset(e) {
    if (this.visibility) {
      const n = e.box[1];
      return this.scale * n + this.visibility.offset;
    }
    return null;
  }
  #m() {
    this.graphics.overlay.g.clearRect(0, 0, this.page.width, this.page.height);
  }
}
function Js(t, e, n) {
  const i = [];
  for (const r of n.filter((c) => c.page === t))
    if (r.t === "t")
      for (const c of r.chars)
        i.push(c);
  const s = i.map((r) => r.c).join("").toLowerCase(), o = e.toLowerCase().split(/\s+/).map((r) => {
    const c = s.indexOf(r.toLowerCase());
    return c > -1 ? i.slice(c, c + r.length) : null;
  });
  for (const r of o)
    if (!r)
      return [i];
  return o;
}
function Ks(t) {
  const e = qt(t);
  if (e) {
    const n = e.chars[0];
    if (n)
      return n.box;
  }
}
class Qt {
  constructor(e, n, i, s, o, r, c, a, h, f) {
    this.index = e, this.scan = s, this.diff = o, this.miniMap = f, this.#t = {
      index: e,
      opts: n,
      scan: s,
      search: {
        term: "",
        matches: [],
        index: 0
      },
      selections: /* @__PURE__ */ new Map(),
      selectedRelations: /* @__PURE__ */ new Map(),
      hoveredRelations: /* @__PURE__ */ new Map(),
      selectedChars: /* @__PURE__ */ new Map(),
      hoveredChars: /* @__PURE__ */ new Map()
    }, this.#e = i, this.#n = a, this.#i = h - n.toolbarHeight, f.doc = this, this.#h = new ns(
      "Page number",
      6 * 8,
      n.toolbarHeight - 4,
      1,
      1,
      s.pages.length,
      1,
      (p) => {
        this.jumpToPage(p - 1);
      }
    ), this.#r = new Bs(
      this.#t,
      n.toolbarHeight - 4,
      async (p, d) => await this.#A(p, d),
      async (p, d) => await this.#R(p, d)
    ), this.#u = new js(
      n.toolbarHeight - 4,
      Tt,
      Tt[0],
      async (p) => {
        await this.draw(p);
      }
    );
    const l = m(
      {
        position: "absolute",
        left: "0",
        top: "0",
        right: "0",
        height: g(n.toolbarHeight),
        display: "flex",
        alignItems: "center",
        border: `1px solid ${w.zinc.c300}`,
        boxSizing: "border-box",
        paddingLeft: M(1),
        paddingRight: M(1),
        background: n.toolbarColor,
        color: n.toolbarTextColor
      },
      m(
        {
          display: "flex",
          alignItems: "center",
          gap: g(4)
        },
        _(qi, 20, "Outline", () => this.#x()),
        _(Ji, 20, "Search", () => this.#k()),
        this.#r.root
      ),
      m(
        {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          flexGrow: "1"
        },
        this.#h.root,
        Mn(`of ${s.pages.length}`),
        _(wn, 20, "Page up", () => this.#h.scroll(-1)),
        _(we, 20, "Page down", () => this.#h.scroll(1))
      ),
      m(
        {
          display: "flex",
          alignItems: "center"
        },
        _(Gi, 20, "Zoom in", async () => {
          await this.#M();
        }),
        _(Ui, 20, "Zoom out", async () => {
          await this.#C();
        }),
        _(Zi, 20, "Reset zoom", async () => {
          await this.#S();
        }),
        this.#u.root
      )
    ), u = m({
      position: "absolute",
      left: "0",
      top: g(n.toolbarHeight),
      bottom: "0",
      right: "0",
      overflow: "auto",
      display: "flex",
      flexWrap: "wrap",
      gap: M(1),
      justifyContent: "center",
      alignItems: "center"
    });
    u.addEventListener(
      "scroll",
      Ot(500, async () => await this.draw(this.#l))
    ), this.#o = u, this.#a = new ps(s, (p, d) => this.#I(p, d)), this.#c = new ds(n, this.#n, this.#i), this.root = m(
      {
        position: "absolute",
        left: g(r),
        top: g(c),
        width: g(a),
        height: g(h)
      },
      l,
      u,
      this.#a.root,
      this.#c.root
    );
  }
  #t;
  #e;
  #n;
  #i;
  root;
  #o;
  #a;
  #r;
  #c;
  #u;
  #h;
  onZoom = is();
  #s = [];
  #l = Ys;
  relationMap;
  scrollBy(e) {
    this.#h.scroll(Math.round(e / 100));
  }
  async toggleLens(e) {
    if (e) {
      const n = this.#s[e.id];
      if (!n.visibility) {
        await this.#c.show(n);
        return;
      }
    }
    await this.#c.show(null);
  }
  async draw(e) {
    if (e !== this.#l) {
      this.#l = e;
      const i = this.#n - es(), s = this.#i, o = this.#e;
      this.#s = this.scan.pages.map((r) => {
        const c = async (h) => {
          await this.#d(h);
        }, a = async (h, f) => {
          await this.#b(r, h, f);
        };
        return new Zs(
          this.#t,
          i,
          s,
          e,
          o,
          r,
          this.diff,
          a,
          c
        );
      }), Bt(
        this.#o,
        this.#s.map((r) => r.root)
      ), this.onZoom.fire(e);
    }
    this.#p();
    const n = Qs(this.#s);
    n && this.miniMap.selectViewport(n), await this.#g(), this.#m();
  }
  async #g() {
    for (const e of this.#s)
      await e.draw();
  }
  #p() {
    const e = this.#o.getBoundingClientRect();
    for (const n of this.#s) {
      const i = n.root.getBoundingClientRect();
      if (i.top < e.bottom && i.bottom > e.top) {
        const o = i.height, r = i.top - e.top, c = Math.max(0, -r), a = Math.min(o, i.height + e.bottom - i.bottom);
        n.visibility = {
          offset: r,
          start: c / o,
          end: a / o,
          span: (a - c) / o
        };
      } else
        n.visibility = null;
    }
  }
  async hoverRelations(e) {
    const n = this.#t, i = /* @__PURE__ */ new Set();
    V(i, n.hoveredRelations), n.hoveredRelations = on(e), V(i, n.hoveredRelations), await this.#f(i);
  }
  async selectRelations(e, n) {
    const i = this.#t, s = /* @__PURE__ */ new Set();
    V(s, i.selectedRelations), i.selectedRelations = on(e), V(s, i.selectedRelations), e.length && this.#N(e[0], n), await this.#f(s);
  }
  async hoverChars(e) {
    const n = this.#t, i = /* @__PURE__ */ new Set();
    V(i, n.hoveredChars), n.hoveredChars = sn(e), V(i, n.hoveredChars), await this.#f(i);
  }
  async selectChars(e, n) {
    const i = this.#t, s = /* @__PURE__ */ new Set();
    console.log(i), V(s, i.selectedChars), i.selectedChars = sn(e), V(s, i.selectedChars), this.#_(e, n), await this.#f(s);
  }
  async #f(e) {
    for (const n of e) {
      const i = this.#s[n.id];
      i && await i.invalidate();
    }
  }
  async #d(e) {
    const n = e ? [e] : [];
    this.miniMap.hoverParts(n), this.relationMap && await this.relationMap.hover(this, n);
  }
  async #b(e, n, i) {
    const s = this.#t, o = /* @__PURE__ */ new Set(), r = s.selections;
    for (const a of r.keys())
      o.add(a);
    if (n.length) {
      if (i) {
        const a = s.selections.get(e);
        if (a)
          for (const h of n)
            a.has(h) ? a.delete(h) : a.add(h);
        else
          s.selections.set(e, new Set(n));
      } else {
        const a = /* @__PURE__ */ new Map();
        a.set(e, new Set(n)), s.selections = a;
      }
      o.add(e);
    } else
      i || (s.selections = /* @__PURE__ */ new Map());
    const c = [];
    for (const a of s.selections.values())
      c.push(...a);
    this.miniMap.selectParts(c), this.relationMap && await this.relationMap.select(this, c), this.#t.opts.onSelect(this.#e, this.scan, c), await this.#f(o);
  }
  #m() {
    const e = Ws(this.#s, ({ visibility: n }) => n ? n.span : 0);
    e && this.#h.setValue(e.page.id + 1, !0);
  }
  #x() {
    this.#a.toggle();
  }
  #k() {
    this.#r.toggle();
  }
  async #y(e) {
    this.#u.select(e), await this.draw(e.value);
  }
  async zoom(e) {
    await this.#y(Gs(e));
  }
  async #M() {
    await this.#y(en(this.#l, this.#v(), 1));
  }
  async #C() {
    await this.#y(en(this.#l, this.#v(), -1));
  }
  async #S() {
    await this.draw(lt);
  }
  #v() {
    return this.#s[0].scale;
  }
  async #A(e, n) {
    this.miniMap.selectMatches(n.matches), await this.#f(le(e.matches, n.matches));
  }
  async #R(e, n) {
    const i = e.matches[e.index], s = n.matches[n.index];
    await this.#f(le([i, s])), this.#w(s.nodes, 0);
  }
  jumpToPage(e) {
    this.#s[e]?.jumpTo();
  }
  jumpToPageOffset(e, n) {
    const i = this.#s[e.id];
    i && i.jumpToOffset(0, n);
  }
  #I(e, n) {
    this.#a.hide(), this.#w(e.heading.nodes, n);
  }
  #N(e, n) {
    const { targets: i } = e;
    i.length && this.#w(i[0].nodes, n);
  }
  #_(e, n) {
    e.length && this.#w([e[0].node], n);
  }
  #w(e, n) {
    const i = qt(e);
    i && this.#s[i.page.id].jumpToNode(e, n);
  }
  calculateNodeOffset(e) {
    return this.#s[e.page.id].calculateNodeOffset(e);
  }
}
function sn(t) {
  if (!t.length)
    return /* @__PURE__ */ new Map();
  const e = /* @__PURE__ */ new Map();
  for (const n of t) {
    let i = e.get(n.node.page);
    i || e.set(n.node.page, i = /* @__PURE__ */ new Set()), i.add(n);
  }
  return e;
}
function on(t) {
  if (!t.length)
    return /* @__PURE__ */ new Map();
  const e = /* @__PURE__ */ new Map();
  for (const { targets: n } of t) {
    const i = le(n);
    for (const s of i) {
      let o = e.get(s);
      o || e.set(s, o = /* @__PURE__ */ new Set());
      for (const r of t)
        o.add(r);
    }
  }
  return e;
}
function Qs(t) {
  let e = null, n = null;
  for (let i = 0; i < t.length; i++) {
    const s = t[i], { visibility: o } = s;
    if (o)
      e ? n = { page: s.page, visibility: o } : e = { page: s.page, visibility: o };
    else {
      if (n)
        break;
      if (e) {
        n = e;
        break;
      }
    }
  }
  return e && n ? { from: e, to: n } : null;
}
function V(t, e) {
  for (const n of e.keys())
    t.add(n);
}
function le(...t) {
  const e = /* @__PURE__ */ new Set();
  for (const n of t)
    for (const i of n)
      for (const s of jn(i.nodes))
        e.add(s.page);
  return e;
}
class to {
  #t;
  #e;
  #n;
  constructor(e, n) {
    this.#e = n;
    let i = 0;
    for (const c of e)
      i += c.height;
    const s = n / i;
    let o = 0;
    const r = [];
    for (const c of e) {
      const a = o + c.height;
      r.push({ page: c, y0: o * s, y1: a * s }), o = a;
    }
    this.#n = s, this.#t = r;
  }
  scale(e, n) {
    return n * this.#n + this.#t[e.id].y0;
  }
  invert(e) {
    e *= this.#e;
    const n = this.#t;
    let i = n.length - 1;
    for (; i >= 0 && e < n[i].y0;)
      i--;
    const s = n[i], o = (e - s.y0) / (s.y1 - s.y0);
    return [s.page, o];
  }
}
class eo {
  constructor(e) {
    this.width = e;
  }
  scale(e, n) {
    return n * this.width / e.width;
  }
}
class te {
  constructor(e, n, i, s, o, r, c) {
    this.index = e, this.scan = n, this.diff = i, this.width = r, this.height = c, this.scaleX = new eo(r), this.scaleY = new to(this.scan.pages, c), this.#t = q(r, c), this.#e = q(r, c), this.#e.g.lineWidth = 2;
    const a = this.scan.pages[0];
    this.#h = {
      from: { page: a, visibility: null },
      to: { page: a, visibility: null }
    };
    const h = xe(r, c, {
      cursor: "pointer"
    });
    h.g.lineWidth = 2, h.g.font = "bold 24px sans-serif", h.g.textAlign = "center", h.g.textBaseline = "middle", h.g.fillStyle = w.zinc.c400;
    let f = !1, l = !1, u = 0;
    const p = async () => {
      if (f && l) {
        const [b, k] = this.scaleY.invert(u / this.height);
        await this.#s(b);
      }
    }, { canvas: d } = h;
    d.addEventListener("mouseenter", async () => {
      f = !0, await this.#s(null), vn(500, async () => {
        l = !0, await p();
      });
    }), d.addEventListener("mouseleave", async () => {
      f = !1, l = !1, await this.#s(null);
    }), d.addEventListener(
      "mousemove",
      Ot(250, async (b) => {
        u = b.offsetY, await p();
      })
    ), d.addEventListener("click", async (b) => {
      const [k, S] = this.scaleY.invert(b.offsetY / this.height);
      await this.#s(null), this.doc && this.doc.jumpToPageOffset(k, S);
    }), d.addEventListener("wheel", async (b) => {
      b.preventDefault(), await this.#s(null), this.doc && this.doc.scrollBy(b.deltaY);
    }), this.#n = h, this.root = m(
      {
        position: "absolute",
        left: g(s),
        top: g(o),
        width: g(r),
        height: g(c)
      },
      this.#t.canvas,
      this.#e.canvas,
      this.#n.canvas
    ), this.#m();
  }
  root;
  #t;
  #e;
  #n;
  scaleX;
  scaleY;
  doc;
  #i = [];
  #o = [];
  #a = [];
  #r = [];
  #c = [];
  #u = null;
  #h;
  async #s(e) {
    this.#u != e && (this.#u = e, this.#l(e), this.doc && await this.doc.toggleLens(e));
  }
  #l(e) {
    const n = this.#n.g;
    if (n.clearRect(0, 0, this.width, this.height), e) {
      const i = this.scaleY.scale(e, 0), s = this.scaleY.scale(e, e.height);
      n.strokeStyle = w.zinc.c400, n.strokeRect(1, i + 1, this.width - 2, s - i - 2);
      const o = "" + (e.id + 1), r = this.width / 2, c = (i + s) / 2;
      n.strokeStyle = "#fff", n.strokeText(o, r, c), n.fillText(o, r, c);
    }
  }
  #g({ from: e, to: n }) {
    if (!e.visibility || !n.visibility)
      return;
    const i = this.#e.g;
    i.strokeStyle = w.red.c700;
    const s = this.scaleY.scale(e.page, e.visibility.start * e.page.height), o = this.scaleY.scale(n.page, n.visibility.end * n.page.height);
    i.strokeRect(1, s + 1, this.width - 2, o - s - 2);
  }
  #p(e, n) {
    for (const i of e)
      this.#f(i, n);
  }
  #f(e, n) {
    const i = this.#e.g, { scaleX: s, scaleY: o } = this;
    i.fillStyle = n;
    for (const r of e.nodes)
      if (r.t === "t") {
        const [c, a, h, f] = r.box, l = s.scale(r.page, c), u = o.scale(r.page, a);
        i.fillRect(l, u, s.scale(r.page, h) - l, o.scale(r.page, f) - u);
      }
  }
  #d() {
    this.#e.g.clearRect(0, 0, this.width, this.height), this.#p(this.#o, w.cyan.c500), this.#b(this.#a), this.#b(this.#r), this.#p(this.#i, w.rose.c500), this.#p(this.#c, w.red.c500), this.#g(this.#h);
  }
  #b(e) {
    for (const { targets: n, colors: i } of e)
      for (let s = 0; s < n.length; s++)
        this.#f(n[s], i[s]);
  }
  #m() {
    const e = this.#t.g, n = this.scaleX, i = this.scaleY;
    for (const s of this.scan.pages) {
      e.fillStyle = "#fff", e.fillRect(0, i.scale(s, 0), this.width, i.scale(s, s.height)), e.fillStyle = w.zinc.c950;
      for (const o of s.nodes)
        if (o.t === "t") {
          const [r, c, a, h] = o.box;
          e.fillRect(
            n.scale(s, r),
            i.scale(s, c),
            n.scale(s, a - r),
            i.scale(s, h) - i.scale(s, c)
          );
        }
    }
    this.diff && this.#x(this.diff);
  }
  #x(e) {
    const n = this.index ? e.inserts : e.deletes, i = this.#t.g, s = this.scaleX, o = this.scaleY;
    for (const { t: r, chars: c } of n) {
      i.fillStyle = r === N.Insert ? w.indigo.c500 : w.rose.c500;
      for (const { box: a, node: h } of c)
        if (h.t === "t") {
          const [f, l, u, p] = a, d = h.page;
          i.fillRect(
            s.scale(d, f),
            o.scale(d, l),
            s.scale(d, u - f),
            o.scale(d, p) - o.scale(d, l)
          );
        }
    }
  }
  selectViewport(e) {
    this.#h = e, this.#d();
  }
  selectMatches(e) {
    this.#i = e, this.#d();
  }
  selectParts(e) {
    this.#o = e, this.#d();
  }
  selectRelations(e) {
    this.#a = e, this.#d();
  }
  hoverParts(e) {
    this.#c = e, this.#d();
  }
  hoverRelations(e) {
    this.#r = e, this.#d();
  }
}
const no = {
  toolbarHeight: Z(4.5),
  gap: Z(1),
  miniMapWidth: Z(6),
  relationMapWidth: Z(9),
  highlightOverlayOpacity: 0.3,
  pageLensScale: 0.85,
  backgroundColor: w.zinc.c100,
  toolbarColor: w.zinc.c200,
  toolbarTextColor: w.zinc.c600,
  maxCorrelations: 10,
  changeLogWidth: Z(40),
  lensFadeInterval: 0.5,
  onSelect: (t, e, n) => {
  },
  onDiffSelect: (t, e) => {
  }
}, Hn = {
  id: 0,
  width: 0,
  height: 0,
  nodes: [],
  parts: []
}, io = [0, 0, 0, 0], so = {
  t: "t",
  chars: [],
  box: io,
  page: Hn,
  id: 0
}, de = {};
function rn(t) {
  const e = [];
  for (const n of t.nodes)
    for (const i of n.chars)
      e.push(i);
  return e;
}
function cn(t, e) {
  const n = t.sections.find((i) => i.nodes.includes(e));
  if (n)
    return n;
}
function oo(t, e, n) {
  const { ops: i, chars: s } = n, o = rn(t);
  let r = 0;
  const c = rn(e);
  let a = 0;
  const h = [];
  for (let f = 0; f < i.length; f++) {
    const l = i[f], u = s[f];
    switch (l) {
      case 0:
        r += u, a += u;
        break;
      case 1:
        {
          const p = o.slice(r, r + u);
          if (!an(p)) {
            const d = cn(t, p[0].node);
            h.push({ t: N.Delete, chars: p, section: d || void 0 });
          }
          r += u;
        }
        break;
      case 2:
        {
          const p = c.slice(a, a + u);
          if (!an(p)) {
            const d = cn(e, p[0].node);
            h.push({ t: N.Insert, chars: p, section: d || void 0 });
          }
          a += u;
        }
        break;
    }
  }
  return {
    deletes: h.filter((f) => f.t === N.Delete),
    inserts: h.filter((f) => f.t === N.Insert),
    normalized: ro(h)
  };
}
function ro(t) {
  const e = [];
  for (let n = 0, i = t.length; n < i; n++) {
    const s = t[n];
    if (s.t === N.Delete && n + 1 < i) {
      const o = t[n + 1];
      if (o.t === N.Insert) {
        e.push({
          t: N.Replace,
          delete: s,
          insert: o
        }), n++;
        continue;
      }
    }
    e.push(s);
  }
  return e;
}
function an(t) {
  for (const { c: e } of t)
    if (!(e === "" || e === " " || e === `
` || e === "	"))
      return !1;
  return !0;
}
function ee(t) {
  const e = t.nodes.map(ao);
  for (const c of e)
    for (const a of c.chars)
      a.node = c;
  const n = t.sections.map((c, a) => fo(c, a, e));
  let i = 0;
  const s = [];
  for (const c of n) {
    const a = t.sections[c.id];
    c.sections = a.sections.map((h) => n[h]), c.parent = a.parent === -1 ? null : n[a.parent], c.path = a.path.map((h) => n[h]), c.heading.section = c;
    for (const h of c.parts)
      h.id = i++, h.section = c, s.push(h);
  }
  const o = t.fonts.map(po), r = t.pages.map((c, a) => ho(a, c, e));
  for (const c of r) {
    for (const h of c.nodes)
      h.page = c;
    const a = [];
    for (const h of n)
      for (const f of h.parts)
        co(f, c) && a.push(f);
    c.parts = a;
  }
  return {
    source: t.source,
    nodes: e,
    pages: r,
    sections: n,
    parts: s,
    fonts: o
  };
}
function co(t, e) {
  for (const n of t.nodes)
    if (n.page === e)
      return !0;
  return !1;
}
function ao(t, e) {
  return {
    t: t.t,
    id: e,
    box: t.box,
    page: Hn,
    chars: t.chars.map((n) => ({
      c: n.c,
      box: n.box,
      node: so
    }))
  };
}
function ho(t, e, n) {
  return {
    id: t,
    width: e.width,
    height: e.height,
    nodes: e.nodes.map((i) => n[i]),
    parts: []
  };
}
function fo(t, e, n) {
  return {
    id: e,
    heading: lo(t.heading, n),
    nodes: t.nodes.map((i) => n[i]),
    sections: [],
    parent: null,
    path: [],
    parts: t.parts.map((i) => uo(i, n))
  };
}
function lo(t, e) {
  return {
    t: "h",
    section: de,
    nodes: t.nodes.map((n) => e[n]),
    text: t.text
  };
}
function uo(t, e) {
  switch (t.t) {
    case "l":
      return {
        t: "l",
        id: 0,
        // will be set later
        section: de,
        numbers: t.numbers.map((n) => e[n]),
        nodes: t.nodes.map((n) => e[n]),
        text: t.text
      };
    case "p":
      return {
        t: "p",
        id: 0,
        // will be set later
        section: de,
        nodes: t.nodes.map((n) => e[n]),
        text: t.text
      };
  }
}
function po({ name: t, size: e, flags: n }) {
  return {
    name: t,
    size: e,
    isSuperscript: (n & 1) !== 0,
    isItalic: (n & 2) !== 0,
    isSerif: (n & 4) !== 0,
    isMonospace: (n & 8) !== 0,
    isBold: (n & 16) !== 0
  };
}
class go {
  constructor(e, n, i, s, o, r, c, a, h) {
    this.width = s, this.height = o, this.doc1 = r, this.doc2 = c, this.correlations1 = a, this.correlations2 = h, this.#t = e, r.relationMap = this, c.relationMap = this, this.scan1 = r.scan, this.scan2 = c.scan, this.miniMap1 = r.miniMap, this.miniMap2 = c.miniMap, this.#e = q(s, o), this.#e.g.lineWidth = 2, this.#n = q(s, o), this.#n.g.lineWidth = 2, this.root = m(
      {
        position: "absolute",
        left: g(n),
        top: g(i),
        width: g(s),
        height: g(o)
      },
      this.#e.canvas,
      this.#n.canvas
    );
  }
  root;
  scan1;
  scan2;
  miniMap1;
  miniMap2;
  #t;
  #e;
  #n;
  #i = [];
  #o = [];
  #a({ source: e, targets: n, colors: i }, s, o, r, c, a) {
    const { width: h } = this, f = this.#c(r, e), l = h / 2;
    for (let u = n.length - 1; u >= 0; u--) {
      const p = this.#c(a, n[u]);
      s.strokeStyle = i[u], s.beginPath(), s.moveTo(o, f), s.bezierCurveTo(l, f, l, p, c, p), s.stroke();
    }
  }
  #r(e) {
    e.clearRect(0, 0, this.width, this.height);
  }
  #c(e, n) {
    for (const i of n.nodes)
      if (i.t === "t") {
        const [s, o] = i.box;
        return e.scale(i.page, o);
      }
    return 0;
  }
  #u(e, n) {
    this.#a(e, n, 0, this.miniMap1.scaleY, this.width, this.miniMap2.scaleY);
  }
  #h(e, n) {
    this.#a(e, n, this.width, this.miniMap2.scaleY, 0, this.miniMap1.scaleY);
  }
  async hover(e, n) {
    const i = this.#n.g;
    if (this.#r(i), e === this.doc1) {
      const s = n.map(
        (o) => this.#l(this.correlations1, o, this.scan2.parts, je)
      );
      for (const o of s)
        this.#u(o, i);
      this.miniMap2.hoverRelations(s), await this.doc2.hoverRelations(s);
    } else {
      const s = n.map(
        (o) => this.#l(this.correlations2, o, this.scan1.parts, je)
      );
      for (const o of s)
        this.#h(o, i);
      this.miniMap1.hoverRelations(s), await this.doc1.hoverRelations(s);
    }
  }
  async select(e, n) {
    const i = bo(n);
    if (e === this.doc1) {
      const s = n.map(
        (r) => this.#l(this.correlations1, r, this.scan2.parts, Le)
      );
      this.#i = s, this.miniMap2.selectRelations(s);
      const o = (i ? this.doc1.calculateNodeOffset(i) : 0) || 0;
      await this.doc2.selectRelations(s, o);
    } else {
      const s = n.map(
        (r) => this.#l(this.correlations2, r, this.scan1.parts, Le)
      );
      this.#o = s, this.miniMap1.selectRelations(s);
      const o = (i ? this.doc2.calculateNodeOffset(i) : 0) || 0;
      await this.doc1.selectRelations(s, o);
    }
    this.#s();
  }
  #s() {
    const e = this.#e.g;
    this.#r(e);
    for (const n of this.#i)
      this.#u(n, e);
    for (const n of this.#o)
      this.#h(n, e);
  }
  #l(e, n, i, s) {
    const { maxCorrelations: o } = this.#t, r = n.id, c = e.indices[r].slice(0, o).map((h) => i[h]), a = e.scores[r].slice(0, o).map(s);
    return { source: n, targets: c, colors: a };
  }
}
function bo(t) {
  const e = t[0];
  return e ? qt(e.nodes) : null;
}
const mo = fn(
  {
    paddingLeft: M(1),
    paddingRight: M(1)
  },
  {
    ":hover": {
      textDecoration: "underline"
    }
  }
);
class wo {
  constructor(e, n, i, s, o, r, c) {
    this.opts = e, this.left = n, this.top = i, this.width = s, this.height = o, this.choices = r;
    const a = r.map((h) => {
      const f = document.createElement("button");
      return f.className = mo, f.textContent = h.label, f.addEventListener("click", () => c(h.value)), f;
    });
    this.root = m(
      {
        position: "absolute",
        left: g(n),
        top: g(i),
        width: g(s),
        height: g(o),
        fontSize: g(12),
        transform: "rotate(90deg) translate(0, -100%)",
        transformOrigin: "0% 0%",
        display: "flex",
        alignItems: "stretch",
        overflow: "hidden",
        color: e.toolbarTextColor,
        background: e.toolbarColor
      },
      ...a
    );
  }
  root;
}
class xo {
  constructor(e, n, i, s, o, r) {
    this.doc1 = o, this.doc2 = r, this.#t = _(Wi, 16, "Scroll sync locked", () => {
      this.#i();
    }), this.#e = _(Yi, 16, "Scroll sync unlocked", () => {
      this.#i();
    });
    const c = {
      top: g(s / 2),
      height: g(0),
      borderTop: `1px solid ${w.zinc.c300}`,
      flexGrow: "1"
    };
    this.root = m(
      {
        position: "absolute",
        left: g(e),
        top: g(n),
        width: g(i),
        height: g(s),
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        gap: M(1)
      },
      m(c),
      this.#t,
      this.#e,
      m(c)
    ), o.onZoom.on(async (a) => {
      this.#n && await r.zoom(a);
    }), r.onZoom.on(async (a) => {
      this.#n && await o.zoom(a);
    }), this.#i();
  }
  root;
  #t;
  #e;
  #n = !0;
  #i() {
    this.#n = !this.#n, this.#n ? jt(this.#e, this.#t) : jt(this.#t, this.#e);
  }
}
class yo {
  #t;
  #e;
  #n;
  #i;
  #o = !0;
  constructor(e, n, i) {
    Xn(), this.#t = e, this.#i = n, this.#e = { ...no, ...i }, this.#n = new ResizeObserver(
      Ot(1e3, async (s) => {
        s.length && await this.render();
      })
    ), this.#n.observe(this.#t);
  }
  async render() {
    const e = this.#i, { width: n, height: i } = this.#t.getBoundingClientRect(), s = this.#e, o = i - s.toolbarHeight;
    this.#t.className = "h2o-pdf";
    const r = m({
      position: "absolute",
      inset: "0",
      backgroundColor: s.backgroundColor
    });
    switch (ts(this.#t, r), e.mode) {
      case "single": {
        const {
          pdf: c,
          scan: { document: a }
        } = e.document, h = ee(a), f = n - s.gap - s.miniMapWidth, l = new te(
          0,
          h,
          null,
          f + s.gap,
          s.toolbarHeight,
          s.miniMapWidth,
          o
        ), u = new Qt(0, s, c, h, null, 0, 0, f, i, l);
        Bt(r, [u.root, l.root]), await u.draw(lt);
        break;
      }
      case "compare": {
        const [a, h] = e.documents, [f, l] = e.analysis.correlations, u = ee(a.scan.document), p = h ? ee(h.scan.document) : u, d = e.diff ? oo(u, p, e.diff) : null, b = a.pdf, k = h ? h.pdf : b, S = d && this.#o, x = (n - 2 * (s.gap + s.miniMapWidth) - s.relationMapWidth - (S ? s.gap + s.changeLogWidth : 0) - (d ? s.gap + 24 : 0)) / 2, v = x + s.gap, B = new te(
          0,
          u,
          d,
          v,
          s.toolbarHeight,
          s.miniMapWidth,
          o
        ), A = x + s.gap + s.miniMapWidth, T = A + s.relationMapWidth, F = new te(
          1,
          p,
          d,
          T,
          s.toolbarHeight,
          s.miniMapWidth,
          o
        ), H = new Qt(0, s, b, u, d, 0, 0, x, i, B), et = T + s.miniMapWidth + s.gap, Y = new Qt(
          1,
          s,
          k,
          p,
          d,
          et,
          0,
          x,
          i,
          F
        ), y = new go(
          this.#e,
          A,
          s.toolbarHeight,
          s.relationMapWidth,
          o,
          H,
          Y,
          f,
          l || f
        ), D = new xo(
          v,
          0,
          s.miniMapWidth * 2 + s.relationMapWidth,
          s.toolbarHeight,
          H,
          Y
        ), $ = et + x, O = S && d && e.changeLog ? new ls(
          s,
          $ + s.gap,
          0,
          s.changeLogWidth,
          i,
          H,
          Y,
          d,
          e.changeLog,
          s.onDiffSelect,
          async () => {
            this.#o = !1, await this.render();
          }
        ) : null, nt = [
          H.root,
          B.root,
          D.root,
          y.root,
          F.root,
          Y.root
        ];
        O && nt.push(O.root);
        const G = d ? new wo(
          s,
          n - 24,
          0,
          i,
          24,
          [
            {
              value: "changes",
              label: "Changes"
            }
          ],
          async (ct) => {
            this.#o = !this.#o, await this.render();
          }
        ) : null;
        G && nt.push(G.root), Bt(r, nt), await H.draw(lt), await Y.draw(lt);
        break;
      }
    }
  }
  async dispose() {
    this.#n.disconnect();
    const e = this.#i;
    switch (e.mode) {
      case "single": {
        await e.document.pdf.dispose();
        break;
      }
      case "compare": {
        for (const n of e.documents)
          await n.pdf.dispose();
        break;
      }
    }
  }
}
export {
  yo as Viewer
};
